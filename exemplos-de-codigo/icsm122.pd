#N canvas 0 0 1280 700 16;
#X declare -lib ofelia;
#X declare -path ofelia/abs;
#X declare -lib ofelia;
#X declare -path ofelia/abs;
#X declare -lib zexy;
#X declare -lib zexy;
#X declare -lib ofelia;
#X declare -path ofelia/abs;
#X obj 0 0 icsm_cabecalho;
#X obj 100 200 cnv 15 14 14 empty empty 1.2.2_Transformada_de_Fourier
0 0 0 34 -262144 -38 0;
#X text 390 386 exp_f[n] = e;
#X text 510 376 i2πfn/N;
#X text 590 386 = cos(2πfn/N)+i·sen(2πfn/N);
#X text 100 250 Inicialmente \, é importante observar que existem
várias Transformadas de Fourier \, que diferem entre si entre outras
coisas pelo conjunto de sinais considerado como domínio de partida
e pela base de funções usada na representação. Sua forma mais comum
é a TRANSFORMADA DE FOURIER DISCRETA (DFT = Discrete Fourier Transform)
que considera como domínio de partida vetores de N componentes (REAIS
ou COMPLEXAS) e como base de representação as funções EXPONENCIAIS
COMPLEXAS associadas à expressão, f 107;
#N canvas 0 0 877 703 icsm122A 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm122A vis 1;
#X obj 100 110 cnv 15 14 14 empty empty Exponenciais_complexas_e_rebatimento
0 0 0 28 -262144 -38 0;
#N canvas 0 0 251 160 \$0_122A_interface 0;
#X floatatom 13 27 8 -64 64 2 Frequência #0_122A_freq_r #0_122A_freq
;
#X floatatom 12 104 8 -3.1415 3.1415 1 Fase_inicial #0_122A_fase_r
#0_122A_fase;
#X floatatom 13 64 8 0 2 1 Amplitude #0_122A_amp_r #0_122A_amp;
#N canvas 0 0 1280 700 magic 0;
#X obj 803 470 ofWindow;
#X obj 39 66 ofSetup;
#X obj 523 25 declare -lib ofelia;
#X text 36 19 Adaptado do exemplo motion/brownian do [ofelia];
#X obj 709 318 r \$0_122A_popup;
#X obj 637 151 r \$0_122A_freq;
#X msg 637 180 freq \$1;
#X obj 787 151 r \$0_122A_amp;
#X msg 787 180 amp \$1;
#X obj 637 243 r \$0_122A_fase;
#X msg 637 280 fase \$1;
#X obj 709 377 sel 0;
#X msg 673 409 destroy;
#X msg 803 440 setPosition 880 0 \, setSize 400 400 \, create;
#X obj 1031 110 loadbang;
#X obj 1031 139 f \$0;
#X obj 756 409 t b b;
#X text 1030 79 inicializações;
#X text 636 116 recebe variações de freq \, amp \, fase;
#X obj 39 322 ofDraw;
#X obj 39 351 spigot;
#X obj 709 347 t f f;
#X text 38 844 .;
#X msg 1031 168 \; \$1_122A_freq_r 0.5 \; \$1_122A_amp_r 1 \; \$1_122A_fase_r
0;
#X obj 39 115 ofelia f \$0-vars \; ofBackground(51) \; ofSetFrameRate(30)
\; M.num \, M.freq \, M.amp \, M.fase \, M.N = 10 \, 1 \, 1 \, 0 \,
30 \; M.ax \, M.ay = ofTable() \, ofTable() \; for i=1 \, M.num do
\; M.ax[i] = 300 \; M.ay[i] = 200 \; end \;;
#X obj 733 25 declare -path ofelia/abs;
#X obj 39 379 ofelia f \; local a=require("\$0-vars") \; local function
x2i(x) return 200+math.floor(0.5+100*x) end \; local function y2j(y)
return 200-math.floor(0.5+100*y) end \; for i=2 \, a.num do \; a.ax[i-1]
= a.ax[i] \; a.ay[i-1] = a.ay[i] \; end \; a.ax[a.num] = x2i(a.amp*math.cos(a.fase))
\; a.ay[a.num] = y2j(a.amp*math.sin(a.fase)) \; a.fase = a.fase+2*math.pi*a.freq/a.N
\; for i=2 \, a.num do \; local val = i/a.num * 204 + 51 \; ofSetColor(val)
\; ofDrawLine(a.ax[i-1] \, a.ay[i-1] \, a.ax[i] \, a.ay[i]) \; end
\;;
#X connect 1 0 24 0;
#X connect 4 0 21 0;
#X connect 5 0 6 0;
#X connect 6 0 24 0;
#X connect 7 0 8 0;
#X connect 8 0 24 0;
#X connect 9 0 10 0;
#X connect 10 0 24 0;
#X connect 11 0 12 0;
#X connect 11 1 16 0;
#X connect 12 0 0 0;
#X connect 13 0 0 0;
#X connect 14 0 15 0;
#X connect 15 0 23 0;
#X connect 16 0 15 0;
#X connect 16 1 13 0;
#X connect 19 0 20 0;
#X connect 20 0 26 0;
#X connect 21 0 11 0;
#X connect 21 1 20 1;
#X restore 501 600 pd magic;
#X obj 151 27 tgl 20 0 \$0_122A_popup empty LIGA 24 10 0 18 -262130
-1 -1 0 1;
#X text 95 27 Hz;
#X coords 0 -1 1 1 230 140 2 0 0;
#X restore 560 158 pd \$0_122A_interface;
#X text 100 150 As funções exponenciais complexas usadas pela Transformada
de Fourier podem ser visualizadas através de animações no plano.
A animação ao lado usa 30 quadros/segundo \, e podemos imaginar vetores
de tamanho N=30 descrevendo as trajetórias indicadas na figura. Observe
como os parâmetros de frequência \, amplitude e fase inicial afetam
a animação \, que se repete a cada 1 segundo., f 44;
#X text 100 591 f=-N/2+1 \, ... \, -1 \, 0 \, 1 \, ... \, N/2.;
#N canvas 0 0 877 700 icsm122B 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm122B vis 1;
#X obj 100 110 cnv 15 14 14 empty empty Frequências_negativas_e_sinais_reais
0 0 0 28 -262144 -38 0;
#N canvas 0 0 253 200 \$0_122B_interface 0;
#X floatatom 13 27 8 0 64 2 Frequência #0_122B_freq_r #0_122B_freq
;
#X floatatom 12 104 8 -3.1415 3.1415 1 Fase_inicial #0_122B_fase_r
#0_122B_fase;
#X floatatom 13 64 8 0 2 1 Amp #0_122B_amp_r #0_122B_amp;
#N canvas 0 0 1280 700 magic 0;
#X obj 1014 414 ofWindow;
#X obj 39 46 ofSetup;
#X obj 39 329 ofDraw;
#X obj 533 19 declare -lib ofelia;
#X text 36 19 Adaptado do exemplo motion/brownian do [ofelia];
#X msg 637 180 freq \$1;
#X msg 787 180 amp \$1;
#X obj 920 321 sel 0;
#X msg 920 383 destroy;
#X msg 727 280 n 0;
#X msg 1014 384 setPosition 880 0 \, setSize 400 400 \, create;
#X obj 637 240 t f b;
#X obj 1031 110 loadbang;
#X obj 1031 139 f \$0;
#X obj 967 353 t b b;
#X text 1030 79 inicializações;
#X text 636 116 recebe variações de freq \, amp \, fase;
#X obj 637 151 r \$0_122B_freq;
#X obj 637 211 r \$0_122B_fase;
#X obj 787 151 r \$0_122B_amp;
#X obj 920 262 r \$0_122B_popup;
#X obj 39 358 spigot;
#X obj 920 291 t f f;
#X text 45 867 .;
#X msg 1031 168 \; \$1_122B_freq_r 0.5 \; \$1_122B_amp_r 1 \; \$1_122B_fase_r
0;
#X obj 797 221 r \$0_122B_sin;
#X msg 797 250 sin \$1;
#X msg 637 280 fase \$1;
#X obj 733 19 declare -path ofelia/abs;
#X obj 39 85 ofelia f \$0-vars2 \; ofBackground(0) \; ofSetFrameRate(30)
\; M.num \, M.freq \, M.amp \, M.fase \, M.N \, M.sin = 10 \, 1 \,
1 \, 0 \, 30 \, 0 \; M.ax \, M.ay = ofTable() \, ofTable() \; M.bx
\, M.by = ofTable() \, ofTable() \; M.cx \, M.cy = ofTable() \, ofTable()
\; for i=1 \, M.num do \; M.ax[i] \, M.bx[i] \, M.cx[i] = 300 \, 300
\, 300 \; M.ay[i] \, M.by[i] \, M.cy[i] = 200 \, 200 \, 200 \; end
\;;
#X obj 39 389 ofelia f \; local a = require("\$0-vars2") \; local function
x2i(x) return 200+math.floor(0.5+100*x) end \; local function y2j(y)
return 200-math.floor(0.5+100*y) end \; for i=2 \, a.num do \; a.ax[i-1]
\, a.bx[i-1] \, a.cx[i-1] = a.ax[i] \, a.bx[i] \, a.cx[i] \; a.ay[i-1]
\, a.by[i-1] \, a.cy[i-1] = a.ay[i] \, a.by[i] \, a.cy[i] \; end \;
a.ax[a.num] \, a.ay[a.num] = x2i(a.amp*math.cos(a.fase)) \, y2j(a.amp*math.sin(a.fase))
\; local fase2 = -a.fase+a.sin*math.pi \; a.bx[a.num] \, a.by[a.num]
= x2i(a.amp*math.cos(fase2)) \, y2j(a.amp*math.sin(fase2)) \; a.cx[a.num]
\, a.cy[a.num] = 0.5*(a.ax[a.num]+a.bx[a.num]) \, 0.5*(a.ay[a.num]+a.by[a.num])
\; a.fase = a.fase+2*math.pi*a.freq/a.N \; for i=2 \, a.num do \; ofSetColor(0
\, 0 \, (a.num-i)/a.num * 255) \; ofDrawLine(a.ax[i-1] \, a.ay[i-1]
\, a.ax[i] \, a.ay[i]) \; ofSetColor((a.num-i)/a.num * 255 \, 0 \,
0) \; ofDrawLine(a.bx[i-1] \, a.by[i-1] \, a.bx[i] \, a.by[i]) \; ofSetColor(i/a.num
* 255 \, i/a.num * 255 \, i/a.num * 255) \; ofDrawLine(a.cx[i-1] \,
a.cy[i-1] \, a.cx[i] \, a.cy[i]) \; end \;;
#X f 85;
#X connect 1 0 29 0;
#X connect 2 0 21 0;
#X connect 5 0 29 0;
#X connect 6 0 29 0;
#X connect 7 0 8 0;
#X connect 7 1 14 0;
#X connect 8 0 0 0;
#X connect 9 0 29 0;
#X connect 10 0 0 0;
#X connect 11 0 27 0;
#X connect 11 1 9 0;
#X connect 12 0 13 0;
#X connect 13 0 24 0;
#X connect 14 0 13 0;
#X connect 14 1 10 0;
#X connect 17 0 5 0;
#X connect 18 0 11 0;
#X connect 19 0 6 0;
#X connect 20 0 22 0;
#X connect 21 0 30 0;
#X connect 22 0 7 0;
#X connect 22 1 21 1;
#X connect 25 0 26 0;
#X connect 26 0 29 0;
#X connect 27 0 29 0;
#X restore 501 600 pd magic;
#X obj 151 27 tgl 20 0 \$0_122B_popup empty LIGA 24 10 0 18 -262130
-1 -1 0 1;
#X text 95 27 Hz;
#X obj 151 64 tgl 20 0 \$0_122B_sin empty seno 24 10 0 18 -262130 -1
-1 0 1;
#X coords 0 -1 1 1 230 140 2 0 0;
#X restore 560 158 pd \$0_122B_interface;
#X text 100 140 No contexto da DFT as FREQUÊNCIAS NEGATIVAS têm um
papel muito importante. Pela fórmula de Euler aplicada à frequência
-f vemos que, f 44;
#X text 127 206 exp_-f[n] = cos(-2πfn/N)+i·sen(-2πfn/N);
#X text 100 234 ou seja \, que o movimento circular uniforme descrito
por exp_-f simplesmente muda o sentido de rotação., f 44;
#X text 187 539 Acos(2πfn/N+φ) = ½A·(e;
#X text 497 539 +e;
#X text 617 539 );
#X text 397 561 φ;
#X text 559 561 -φ;
#X text 586 569 ·e;
#X text 684 569 .;
#X text 447 346 e;
#X text 100 387 ou seja \, que as funções cosseno e seno podem ser
vistas como combinações de exponenciais com frequências +f e -f.
A implementação acima ilustra as exponenciais com frequências positivas
em azul e negativas em vermelho. Observe que a resultante no segundo
caso é vertical (i·sen_f)., f 73;
#X text 100 471 De modo ainda mais geral \, um SINAL SENOIDAL GENÉRICO
sempre pode ser escrito como combinação linear de duas exponenciais
complexas de fase 0 \, usando pesos complexos (que contêm informação
de magnitude e fase):, f 73;
#X text 357 569 (½Ae )·e;
#X text 516 569 +(½Ae );
#X text 100 300 Somando e subtraindo as fórmulas de Euler para exp_f
= cos_f+i·sen_f e exp_-f = cos_f-i·sen_f \, podemos concluir que
, f 73;
#N canvas 0 0 876 700 icsm122C 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm122C vis 1;
#N canvas 0 0 1280 700 icsm122D 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm122D vis 1;
#X obj 100 110 cnv 15 14 14 empty empty Análise_e_síntese_na_DFT
0 0 0 28 -262144 -38 0;
#X text 320 222 X[f] = (x \, exp_f) = (x \, cos_f) + i·(x \, -sen_f)
= a[f] + i·b[f] \,, f 63;
#N canvas 0 0 755 580 icsm122_obs_conjugação 0;
#X obj 0 800 bng 15 250 50 0 empty empty * 4 9 0 14 -262144 -1 -1;
#X msg 189 801 \; pd-icsm122_obs_conjugação vis 1;
#X text 165 169 (x \, y) = x[0]y[0]+···+x[N-1]y[N-1];
#X text 295 151 ____;
#X text 445 151 ______;
#X text 65 306 (x \, cy+dz) = x[0](cy[0]+dz[0])+···+x[N-1](cy[N-1]+dz[N-1])
;
#X text 485 289 _______________;
#X text 245 289 ___________;
#X text 175 336 = c(x \, y) + d(x \, z);
#X text 195 319 _;
#X text 295 319 _;
#X text 38 43 A troca de sinal no segundo termo não é um erro \,
mas uma necessidade da definição de correlação e produto interno
em espaços vetoriais definidos sobre números complexos \, a fim de
satisfazer a propriedade (x \, x)>0 para qualquer x (observe que se
x=i então x·x=i²=-1). A expressão do produto interno canônico
(x \, y) = x[0]y[0]+···+x[N-1]y[N-1] no contexto complexo se torna
, f 64;
#X text 38 199 onde a barra indica a operação de CONJUGAÇÃO COMPLEXA
\, que equivale à troca do sinal da parte imaginária. Note que em
particular (i \, i) = i·(-i) = +1>0. Essa pequena diferença na definição
faz com que a propriedade de LINEARIDADE no segundo argumento seja
CONJUGADA:, f 64;
#X text 38 366 o que explica a troca de sinal no segundo termo do coeficiente
de Fourier:, f 64;
#X text 112 419 X[f] = (x \, exp_f) = (x \, cos_f) +i·(x \, sen_f)
;
#X text 432 399 _;
#X text 292 439 = (x \, cos_f) -i·(x \, sen_f);
#X text 292 459 = (x \, cos_f) +i·(x \, -sen_f) \,;
#X text 38 489 usando a correlação com -sen_f exatamente como no
caso da Transformada de Fourier Real., f 64;
#X connect 0 0 1 0;
#X coords 0 -1 1 1 15 15 2 0 800;
#X restore 969 226 pd icsm122_obs_conjugação;
#X obj 454 447 cnv 15 10 10 empty empty Σ 0 0 2 48 -262144 -1 0;
#X text 453 403 N-1;
#X text 453 453 f=0;
#X obj 666 447 cnv 15 10 10 empty empty Σ 0 0 2 48 -262144 -1 0;
#X text 665 403 N-1;
#X text 665 453 f=0;
#X text 701 427 X[f]·(cos_f[n]+i·sen_f[n]).;
#X text 367 427 x[n] = 1;
#X text 489 427 X[f]·exp_f[n] = 1;
#X text 437 428 _;
#X text 649 428 _;
#X text 437 448 N;
#X text 649 448 N;
#X text 100 360 A EQUAÇÃO DE SÍNTESE combina linearmente as exponenciais
complexas de frequências f=0 \, 1 \, ... \, N-1 com os coeficientes
de Fourier e um termo de normalização:, f 107;
#X text 100 262 onde a[f] e b[f] são as mesmas correlações já vistas
na Transformada de Fourier Real \, sendo que a principal diferença
é o fato dos coeficientes X[f] serem complexos (combinarem correlações
de senos e cossenos numa representação Cartesiana) e o uso da faixa
de frequências f=0 \, 1 \, ... \, N-1 ao invés de f=0 \, 1 \, ...
\, N/2., f 107;
#N canvas 0 0 1280 700 icsm122E 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm122E vis 1;
#N canvas 0 0 1280 700 icsm122F 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm122F vis 1;
#N canvas 0 0 1280 700 icsm122G 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#N canvas 0 0 1280 700 icsm122H 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm122H vis 1;
#N canvas 0 0 1280 700 icsm122I 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm122I vis 1;
#X obj 100 110 cnv 15 14 14 empty empty Experimento_com_resolução_de_análise
0 0 0 28 -262144 -38 0;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_122I_espectro_magnitude 64 float 2;
#X coords 0 1 64 0 1074 200 1 0 0;
#X restore 104 342 graph;
#X obj 104 562 hsl 1074 20 0 44100 0 0 empty \$0_122I_freq_r Frequência
-2 -8 0 16 -262144 -1 -1 0 1;
#X floatatom 101 584 8 0 0 1 Hz - #0_122I_freq;
#N canvas 0 0 682 708 \$0_122I_síntese 0;
#X obj 15 63 vradio 24 1 1 7 empty \$0_122I_mux_r empty 0 -8 0 10 -262130
-1 -1 0;
#X text 47 88 RUÍDO;
#X obj 65 269 noise~;
#X obj 15 658 dac~;
#X text 47 63 SILÊNCIO;
#X text 47 111 SENOIDE;
#X text 47 159 QUADRADA;
#X obj 213 420 sgn~;
#X obj 163 358 *~ 2;
#X obj 163 388 -~ 1;
#X obj 12 12 icsm_dsp;
#X obj 315 459 declare -lib zexy;
#X text 47 136 SERRA;
#X obj 163 329 phasor~;
#X obj 114 329 osc~;
#X obj 15 558 *~;
#X msg 42 497 \$1 100;
#X obj 42 526 line~;
#X obj 15 627 *~;
#X msg 255 575 \$1 100;
#X obj 255 604 line~;
#X obj 255 545 expr 1-$f1;
#X obj 155 15 tgl 24 0 empty \$0_122I_mute_r MUTE 28 12 0 20 -262130
-1 -1 0 1;
#X obj 155 65 vsl 20 115 0 1 0 0 empty \$0_122I_vol_r Volume 0 -12
0 16 -262130 -1 -1 0 1;
#X msg 164 268 \$1 100;
#X obj 164 297 line~;
#X obj 164 235 r \$0_122I_freq;
#N canvas 0 0 888 420 \$0_122I_análise 0;
#X obj 37 37 inlet~;
#X obj 37 66 fft~;
#X obj 37 95 cyclone/cartopol~;
#X obj 57 217 bang~;
#X obj 373 37 inlet;
#X obj 406 103 pack f \$0;
#X text 436 36 tamanho do bloco;
#X text 511 101 redimensiona vetor;
#X text 444 220 muda configuração da análise;
#X text 117 124 normaliza espectro;
#X msg 406 132 \; \$2_122I_espectro_magnitude resize \$1;
#X obj 37 263 tabwrite~ \$0_122I_espectro_magnitude;
#X msg 373 185 set \$1 1 1;
#X obj 373 220 block~;
#X obj 37 124 /~ 64;
#X obj 373 66 t f f f;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 1 2 1;
#X connect 2 0 14 0;
#X connect 3 0 11 0;
#X connect 4 0 15 0;
#X connect 5 0 10 0;
#X connect 12 0 13 0;
#X connect 14 0 11 0;
#X connect 15 0 12 0;
#X connect 15 1 5 0;
#X connect 15 2 14 1;
#X restore 22 588 pd \$0_122I_análise;
#X obj 285 17 vradio 20 1 1 8 empty \$0_122I_bloco_r N= -26 10 0 20
-262130 -1 -1 0;
#X text 309 17 64;
#X text 309 56 256;
#X text 309 76 512;
#X text 309 95 1024;
#X text 309 116 2048;
#X text 309 137 4096;
#X text 309 156 8192;
#X obj 399 157 expr 64*pow(2 \, $f1) \; 44100/(64*pow(2 \, $f1));
#X floatatom 285 208 7 0 0 1 Hz - -;
#N canvas 0 0 450 300 init 0;
#X obj 72 41 loadbang;
#X obj 72 70 f \$0;
#X obj 228 41 r pd;
#X obj 228 70 route dsp;
#X obj 228 99 sel 0;
#X msg 72 159 \; \$1_122I_mute_r 0 \; \$1_122I_vol_r 0 \; \$1_122I_mux_r
0 \; \$1_122I_bloco_r 0 \;;
#X connect 0 0 1 0;
#X connect 1 0 5 0;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 4 0 1 0;
#X restore 583 639 pd init;
#X obj 273 370 adc~;
#X obj 336 320 openpanel;
#X obj 336 378 readsf~;
#X msg 336 349 open \$1 \, 1;
#X obj 15 459 multiplex~ 0 1 2 3 4 5 6;
#X text 47 185 MICROFONE;
#X text 47 208 ARQUIVO;
#X obj 336 291 r \$0_122I_load;
#X text 181 188 Resolução Espectral=, f 10;
#X obj 125 209 bng 20 250 50 0 \$0_122I_load empty empty 17 7 0 10
-262130 -1 -1;
#X text 309 36 128;
#X connect 0 0 43 0;
#X connect 2 0 43 1;
#X connect 7 0 43 4;
#X connect 8 0 9 0;
#X connect 9 0 7 0;
#X connect 9 0 43 3;
#X connect 13 0 8 0;
#X connect 14 0 43 2;
#X connect 15 0 18 0;
#X connect 15 0 27 0;
#X connect 16 0 17 0;
#X connect 17 0 15 1;
#X connect 18 0 3 0;
#X connect 18 0 3 1;
#X connect 19 0 20 0;
#X connect 20 0 18 1;
#X connect 21 0 19 0;
#X connect 22 0 21 0;
#X connect 23 0 16 0;
#X connect 24 0 25 0;
#X connect 25 0 14 0;
#X connect 25 0 13 0;
#X connect 26 0 24 0;
#X connect 28 0 36 0;
#X connect 36 0 27 1;
#X connect 36 1 37 0;
#X connect 39 0 43 5;
#X connect 39 1 43 5;
#X connect 40 0 42 0;
#X connect 41 0 43 6;
#X connect 42 0 41 0;
#X connect 43 0 15 0;
#X connect 46 0 40 0;
#X coords 0 -1 1 1 390 250 2 0 0;
#X restore 788 85 pd \$0_122I_síntese;
#X text 100 140 Esse experimento repete a exploração do experimento
anterior com o espectro de magnitude \, porém inclui a possibilidade
de redefinirmos o tamanho de bloco de análise através do objeto [block~].
Para obtermos máxima eficiência no cálculo das DFTs \, as durações
dos blocos (em amostras) são restritas a potências de 2 Observação:
os objetos [adc~] e [dac~] precisam estar em subpatches diferentes
do [block~] \, pois só funcionam com o tamanho de bloco definido na
chamada do Pd.;
#N canvas 0 0 1280 700 icsm122J 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm122J vis 1;
#X obj 100 110 cnv 15 14 14 empty empty Transformada_Rápida_de_Fourier
0 0 0 28 -262144 -38 0;
#X text 100 140 O algoritmo conhecido como FFT (Fast Fourier Transform)
explora propriedades algébricas da DFT para economizar computação.
Existem várias formas de implementar versões rápidas da DFT \, sendo
que a forma mais usual explora a identidade, f 107;
#X text 424 208 X[f] = Xpar[f] + e;
#X text 598 198 -i2πf/N;
#X text 674 208 ·Ximpar[f] \,;
#X text 423 294 FFT(x):;
#X text 463 334 Xpar = FFT(xpar);
#X text 463 354 Ximpar = FFT(ximpar);
#X text 463 374 para f=0 \, ... \, N/2-1;
#X text 493 394 X[f] = Xpar[f]+exp(-i2πf/N)*Ximpar[f];
#X text 493 458 X[f] = X[N-f];
#X text 463 414 X[N/2] = Xpar[0]-Ximpar[0];
#X text 463 434 para f=N/2+1 \, ... \, N-1;
#X text 463 478 devolva X;
#X text 463 314 se |x|=1 devolva X=x;
#X text 563 440 ______;
#N canvas 0 0 1280 700 icsm122K 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm122K vis 1;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_122K_sinal 128 float 2;
#X coords 0 1 128 -1 200 140 1 0 0;
#X restore 726 116 graph;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_122K_real_lua 128 float 2;
#X coords 0 64 128 -64 200 140 1 0 0;
#X restore 726 476 graph;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_122K_imag_lua 128 float 2;
#X coords 0 64 128 -64 200 140 1 0 0;
#X restore 936 476 graph;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_122K_real_pd 128 float 2;
#X coords 0 64 128 -64 200 140 1 0 0;
#X restore 726 296 graph;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_122K_imag_pd 128 float 2;
#X coords 0 64 128 -64 200 140 1 0 0;
#X restore 936 296 graph;
#N canvas 0 0 1183 562 \$0_calcula_fft 0;
#X obj 56 257 block~ 128;
#X obj 123 395 fft~;
#X obj 56 329 t b b b;
#X text 54 201 cálculo da FFT do jeito nativo do Pd:, f 19;
#X obj 56 296 r \$0_122K_atualiza;
#X obj 440 493 ofelia d;
#X msg 440 460 read -c icsm_fftrecursiva.lua;
#X obj 440 425 loadbang;
#X obj 440 36 r \$0_122K_atualiza;
#X text 530 426 lê código do arquivo Lua;
#X obj 860 424 loadbang;
#X obj 860 482 s \$0_122K_atualiza;
#X text 468 65 chama a fft em Lua. A maior parte do código abaixo
simplesmente copia vetores Pd para tabelas em Lua e vice-versa...,
f 63;
#X obj 123 362 tabplay~ \$0_122K_sinal;
#X obj 160 432 tabwrite~ \$0_122K_imag_pd;
#X obj 122 464 tabwrite~ \$0_122K_real_pd;
#X obj 440 383 s \$0_122K_erro;
#X obj 440 106 ofelia f \; local x \, a \, b \, apd \, bpd = ofArray("\$0_122K_sinal")
\, ofArray("\$0_122K_real_lua") \, ofArray("\$0_122K_imag_lua") \,
ofArray("\$0_122K_real_pd") \, ofArray("\$0_122K_imag_pd") \; local
N = x:getSize() \; local v = ofTable() \; for n=0 \, N-1 do v[n+1]
= x[n] end \; local av \, bv=fftrecursiva(v) \; local erro = 0 \; for
n=0 \, N-1 do \; a[n] \, b[n] = av[n+1] \, bv[n+1] \; erro = erro +
math.abs((a[n]-apd[n])^2+(b[n]-bpd[n])^2) \; end \; return math.sqrt(erro/N)
\;;
#X f 61;
#X obj 860 453 metro 0.5 1 sec;
#X connect 1 0 15 0;
#X connect 1 1 14 0;
#X connect 2 0 15 0;
#X connect 2 1 14 0;
#X connect 2 2 13 0;
#X connect 4 0 2 0;
#X connect 6 0 5 0;
#X connect 7 0 6 0;
#X connect 8 0 17 0;
#X connect 10 0 18 0;
#X connect 13 0 1 0;
#X connect 17 0 16 0;
#X connect 18 0 11 0;
#X restore 104 518 pd \$0_calcula_fft;
#X obj 103 471 icsm_dsp;
#X obj 100 110 cnv 15 14 14 empty empty FFT_recursiva_em_Lua 0 0 0
28 -262144 -38 0;
#X floatatom 1054 629 8 0 0 0 Diferença_das_implementações= #0_122K_erro
-;
#X text 592 115 Inicialize o vetor ao lado como quiser->, f 13;
#X text 512 295 Vetores a[f] e b[f] computados pelo objeto [fft~] do
Pd: (só funciona com DSP ligado), f 20;
#X text 512 475 Vetores a[f] e b[f] computados pela FFT recursiva implementada
em Lua:, f 20;
#X text 100 140 A FFT na versão recursiva discutida anteriormente
está implementada em Lua no arquivo icsm_fftrecursiva.lua. Neste patch
você pode comparar a saída do objeto [fft~] do Pd sobre o vetor sinal
com a saída da implementação em Lua. Pequenas diferenças numéricas
podem ocorrer devido à diferença de precisão dos floats nas duas
linguagens. Diferentemente da implementação em tempo real [fft~]
\, a implementação em Lua é chamada "sob demanda" \, e pode ser
utilizada mesmo quando o núcleo de processamento de sinais do Pd está
desligado., f 38;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm122K;
#X text 100 508 A enorme vantagem dessa implementação se expressa
através da noção de COMPLEXIDADE COMPUTACIONAL. Enquanto a implementação
ingênua da DFT tem custo computacional QUADRÁTICO em função de
N (pois cada coeficiente X[f] envolve uma soma de tamanho N) \, a implementação
acima tem CUSTO LINEAR em cada nível da recursão. Como as partições
xpar/ximpar têm metade do tamanho do vetor em cada nível de recursão
\, o máximo de níveis é B=log2(N) \, de onde o custo total é proporcional
a N·log2(N)., f 107;
#X text 100 238 onde X = DFT(x) \, xpar = (x[0] \, x[2] \, ... \, x[N-2])
e ximpar = (x[1] \, x[3] \, ... \, x[N-1]). Essa propriedade pode ser
usada então numa implementação recursiva que fica especialmente
simples se N = 2^B:, f 107;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm122J;
#X connect 1 0 2 0;
#X connect 5 0 6 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm122I;
#X obj 100 110 cnv 15 14 14 empty empty Resolução_da_Análise_de_Fourier_e_Princípio_da_Incerteza
0 0 0 28 -262144 -38 0;
#X text 100 290 Vale lembrar que essas frequências inteiras \, que
representam os ÍNDICES ou BINS da representação espectral \, estando
associadas aos coeficientes a[f] \, b[f] e X[f] \, são medidas em
CICLOS COMPLETOS POR BLOCO. Elas podem ser convertidas em Hz pela expressão
f_Hz = f·R/N \, de onde concluímos que as Transformadas de Fourier
realizam uma DISCRETIZAÇÃO DO ESPECTRO \, utilizando apenas as frequências
pertencentes à SÉRIE HARMÔNICA com fundamental R/N \, sendo que
R/N é também a MENOR DIFERENÇA OBSERVÁVEL entre BINS ADJACENTES
\, um parâmetro conhecido como RESOLUÇÃO ESPECTRAL., f 107;
#X text 100 443 A relação de RECIPROCIDADE entre DURAÇÃO DO BLOCO
DE ANÁLISE (N amostras ou N/R segundos) e RESOLUÇÃO ESPECTRAL (R/N
Hz) é frequentemente denominada PRINCÍPIO DA INCERTEZA em processamento
de sinais \, pois estabelece a impossibilidade de se aumentar simultaneamente
a precisão da LOCALIZAÇÃO TEMPORAL de um evento sonoro (precisão
essa que será tanto MAIOR quanto MENOR for a duração do bloco de
análise) e a precisão de sua LOCALIZAÇÃO ESPECTRAL (que será tanto
MAIOR quanto MAIOR for a duração do bloco de análise)., f 107;
#X text 100 160 Como visto em todos os exemplos até agora \, o parâmetro
N \, que corresponde à DURAÇÃO EM AMOSTRAS DO BLOCO DE ANÁLISE
do sinal \, DEFINE SIMULTANEAMENTE a coleção de frequências utilizadas
na representação espectral \, ou seja \, as frequências f=0 \, 1
\, ... \, N/2 \, no caso da Transformada de Fourier Real \, e f=0 \,
1 \, ... \, N-1 ou equivalentemente f=-N/2+1 \, ... \, N/2 \, no caso
da DFT. Essas frequências inteiras representam TODAS AS COMPONENTES
SENOIDAIS DISPONÍVEIS para a representação espectral usando blocos
de N amostras., f 107;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm122H;
#X obj 100 110 cnv 15 14 14 empty empty Experimento_com_síntese_espectral
0 0 0 28 -262144 -38 0;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_122G_espectro_magnitude 1025 float 0;
#X coords 0 0.01 1024 0 1074 150 1 0 0;
#X restore 104 272 graph;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_122G_sinal_sintetizado 1025 float 0;
#X coords 0 0.05 1024 -0.05 1074 150 1 0 0;
#X restore 104 442 graph;
#N canvas 0 0 747 300 \$0_122F_interface 0;
#X obj 90 218 *~;
#X obj 90 247 dac~;
#X msg 311 165 \$1 100;
#X obj 311 194 line~;
#X obj 239 25 bng 20 250 50 0 empty empty Limpa 0 -10 0 16 -262130
-1 -1;
#X obj 339 50 f \$0;
#X obj 94 26 hsl 128 20 0.01 1 0 0 empty \$0_122G_vol_r Volume 0 -10
0 16 -262130 -1 -1 0 1;
#X obj 12 16 icsm_dsp;
#N canvas 0 0 572 300 \$0_122G_síntese 0;
#X obj 47 32 bang~;
#X obj 47 239 outlet~;
#X obj 135 146 bang~;
#X obj 47 140 rifft~;
#X obj 296 19 block~ 2048;
#X obj 47 61 tabplay~ \$0_122G_espectro_magnitude;
#X obj 89 202 tabwrite~ \$0_122G_sinal_sintetizado;
#X obj 207 120 cyclone/poltocar~;
#X connect 0 0 5 0;
#X connect 2 0 6 0;
#X connect 3 0 1 0;
#X connect 3 0 6 0;
#X connect 5 0 3 0;
#X restore 90 173 pd \$0_122G_síntese;
#X msg 339 79 \; \$1_122G_espectro_magnitude const 0 \; \$1_122G_sinal_sintetizado
const 0;
#X connect 0 0 1 0;
#X connect 0 0 1 1;
#X connect 2 0 3 0;
#X connect 3 0 0 1;
#X connect 4 0 5 0;
#X connect 5 0 9 0;
#X connect 6 0 2 0;
#X connect 8 0 0 0;
#X coords 0 -1 1 1 300 60 2 0 0;
#X restore 878 155 pd \$0_122F_interface;
#X msg 189 801 \; pd-icsm122G vis 1;
#X text 100 150 Na interface abaixo você pode construir sinais a partir
da especificação direta de componentes espectrais. Nesse exemplo
usamos a [rfft~] que permite especificar apenas as frequências f=0
\, 1 \, ... \, N/2 (na [fft~] teríamos que "espelhar e conjugar" automaticamente
a metade alta do espectro)., f 76;
#X connect 1 0 7 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm122G;
#X obj 100 110 cnv 15 14 14 empty empty Espectro_de_Magnitude_da_DFT
0 0 0 28 -262144 -38 0;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_122F_espectro_magnitude 2048 float 2;
#X coords 0 1 2048 0 1074 200 1 0 0;
#X restore 104 342 graph;
#X obj 104 562 hsl 1074 20 0 44100 0 0 empty \$0_122F_freq_r Frequência
-2 -8 0 16 -262144 -1 -1 0 1;
#X obj 231 587 tgl 20 0 \$0_122F_quantiza_freq \$0_122F_quantiza_freq_r
quantiza_frequência_(restringe_oscilador_aos_múltiplos_de_R/N) 24
10 0 16 -262130 -1 -1 0 1;
#X floatatom 101 584 8 0 0 1 Hz - #0_122F_freq;
#X text 100 140 No exemplo abaixo podemos visualizar o espectro de
magnitude de uma DFT em blocos de tamanho N=2048 (usando o objeto do
Pd [block~ 2048]) para uma série de sinais conhecidos. Observe como
as senoides de frequência f são representadas por frequências "espelhadas"
+f e -f. A chave "quantiza frequência" ajusta a frequência das senoides
para múltiplos inteiros de R/N \, que coincidem com as frequências
usadas pela análise. Aproveite a mesma implementação para inspecionar
os espectros das formas de onda quadrada e dente-de-serra \, e procure
observar os respectivos padrões de decaimento da amplitude nas séries
harmônicas., f 82;
#N canvas 0 0 682 708 \$0_122F_síntese 0;
#X obj 15 63 vradio 24 1 1 5 empty \$0_122F_mux_r empty 0 -8 0 10 -262130
-1 -1 0;
#X text 47 88 RUÍDO;
#X obj 65 269 noise~;
#X obj 15 658 dac~;
#X text 47 63 SILÊNCIO;
#X text 47 111 SENOIDE;
#X text 47 159 QUADRADA;
#X obj 213 420 sgn~;
#X obj 15 459 multiplex~ 0 1 2 3 4;
#X obj 163 358 *~ 2;
#X obj 163 388 -~ 1;
#X obj 12 12 icsm_dsp;
#X obj 225 459 declare -lib zexy;
#X text 47 136 SERRA;
#X obj 163 329 phasor~;
#X obj 114 299 osc~;
#X obj 15 558 *~;
#X msg 42 497 \$1 100;
#X obj 42 526 line~;
#X obj 15 627 *~;
#X msg 255 575 \$1 100;
#X obj 255 604 line~;
#X obj 255 545 expr 1-$f1;
#X obj 155 15 tgl 24 0 empty \$0_122F_mute_r MUTE 28 12 0 20 -262130
-1 -1 0 1;
#X obj 155 65 vsl 20 115 0 1 0 0 empty \$0_122F_vol_r Volume 0 -12
0 16 -262130 -1 -1 0 1;
#X obj 254 173 multiplex;
#X msg 254 202 \$1 100;
#X obj 254 231 line~;
#X obj 254 98 expr $f1 \; round($f1*2048/44100)*44100/2048;
#N canvas 0 0 450 300 init 0;
#X obj 72 41 loadbang;
#X obj 72 70 f \$0;
#X obj 228 41 r pd;
#X obj 228 70 route dsp;
#X obj 228 99 sel 0;
#X msg 72 159 \; \$1_122F_mute_r 0 \; \$1_122F_vol_r 0 \; \$1_122F_mux_r
0;
#X connect 0 0 1 0;
#X connect 1 0 5 0;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 4 0 1 0;
#X restore 583 639 pd init;
#X obj 341 14 r \$0_122F_quantiza_freq;
#X obj 254 69 r \$0_122F_freq;
#N canvas 0 0 450 300 \$0_122F_análise 0;
#X obj 37 37 inlet~;
#X obj 37 66 fft~;
#X obj 37 95 cyclone/cartopol~;
#X obj 37 124 /~ 2048;
#X obj 282 40 block~ 2048;
#X obj 57 187 bang~;
#X obj 37 233 tabwrite~ \$0_122F_espectro_magnitude;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 1 2 1;
#X connect 2 0 3 0;
#X connect 3 0 6 0;
#X connect 5 0 6 0;
#X restore 22 588 pd \$0_122F_análise;
#X connect 0 0 8 0;
#X connect 2 0 8 1;
#X connect 7 0 8 4;
#X connect 8 0 16 0;
#X connect 9 0 10 0;
#X connect 10 0 7 0;
#X connect 10 0 8 3;
#X connect 14 0 9 0;
#X connect 15 0 8 2;
#X connect 16 0 19 0;
#X connect 16 0 32 0;
#X connect 17 0 18 0;
#X connect 18 0 16 1;
#X connect 19 0 3 0;
#X connect 19 0 3 1;
#X connect 20 0 21 0;
#X connect 21 0 19 1;
#X connect 22 0 20 0;
#X connect 23 0 22 0;
#X connect 24 0 17 0;
#X connect 25 0 26 0;
#X connect 26 0 27 0;
#X connect 27 0 15 0;
#X connect 27 0 14 0;
#X connect 28 0 25 0;
#X connect 28 1 25 1;
#X connect 30 0 25 2;
#X connect 31 0 28 0;
#X coords 0 -1 1 1 240 196 2 0 0;
#X restore 938 135 pd \$0_122F_síntese;
#X connect 1 0 2 0;
#X connect 6 0 8 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm122F;
#X obj 100 110 cnv 15 14 14 empty empty Simetria_Conjugada_da_DFT_de_sinais_reais
0 0 0 28 -262144 -38 0;
#X text 258 244 a[-f] = (x \, cos_-f) = (x \, cos_f) = a[f] (dizemos
que a[f] é uma função PAR) \,, f 76;
#X text 258 274 b[-f] = (x \, -sen_-f) = (x \, sen_f) = -b[f] (dizemos
que b[f] é uma função ÍMPAR)., f 81;
#X text 258 527 φ[-f] = atan(-b[f] \, a[f]) = -atan(b[f] \, a[f])
= -φ[f] (φ[f] é ÍMPAR)., f 71;
#X text 258 497 A[-f] = sqrt(a[-f]²+b[-f]²) = sqrt(a[f]²+(-b[f])²)
= A[f] (A[f] é PAR) \,, f 72;
#X text 100 440 A mesma SIMETRIA CONJUGADA se manifesta similarmente
na representação polar pela troca de sinal da fase \, que equivale
ao espelhamento em relação ao eixo real:, f 107;
#X text 259 303 _____;
#X text 100 160 No caso particular de um SINAL REAL \, que é o que
nos interessa principalmente \, os coeficientes de Fourier apresentam
uma forma de REDUNDÂNCIA conhecida como SIMETRIA CONJUGADA: se x[n]
é REAL então as correlações de x com os senos e cossenos de fase
0 e frequências +f e -f satisfazem, f 107;
#X text 100 320 ou seja \, X[f] = X[-f] \, onde a barra indica a operação
de CONJUGAÇÃO COMPLEXA \, que equivale à TROCA DE SINAL da parte
imaginária. Com isso \, a "metade alta" do espectro \, contendo as
frequências f>N/2 que rebatem em frequências negativas da forma f-N
(localizadas entre -N/2 e 0) \, simplesmente repete a primeira metade
de forma ESPELHADA e CONJUGADA. Observe que a partidade de a[f] e a
imparidade de b[f] refletem as mesmas propriedades encontradas no cosseno
e no seno \, respectivamente., f 107;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm122E;
#X text 1120 222 (DFT);
#X text 1110 427 (IDFT);
#X text 100 162 Os COEFICIENTES DA DFT são obtidos pela CORRELAÇÃO
de um sinal x=(x[0] \, x[1] \, ... \, x[N]-1) com cada uma das funções
exp_f para f=0 \, 1 \, ... \, N-1 \, ou seja \, pelos valores da EQUAÇÃO
DE ANÁLISE, f 107;
#X text 100 500 O par DFT/IDFT permite a obtenção de uma REPRESENTAÇÃO
ESPECTRAL X para qualquer sinal temporal x \, bem como de uma REPRESENTAÇÃO
TEMPORAL x para qualquer sinal espectral X \, que satisfazem X = DFT(x)
e x = IDFT(X). Apesar de não parecer óbvio \, esse resultado diz
que \, INDEPENDENTEMENTE da origem do sinal x ou DE SEU CONTEÚDO \,
o trecho (x[0] \, x[1] \, ... \, x[N]-1) sempre pode ser representado
e reconstruído perfeitamente utilizando-se apenas as frequências
inteiras f=0 \, 1 \, ... \, N-1., f 107;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 610 600 pd icsm122D;
#X obj 100 110 cnv 15 14 14 empty empty Combinações_de_exponenciais_complexas
0 0 0 28 -262144 -38 0;
#N canvas 0 0 298 296 \$0_122C_interface 0;
#X floatatom 13 27 8 0 64 2 Frequência #0_122C_freq_r #0_122C_freq
;
#X floatatom 12 104 8 1 20 1 Harm #0_122C_harm_r #0_122C_harm;
#X floatatom 13 64 8 0 2 1 Amp #0_122C_amp_r #0_122C_amp;
#N canvas 0 0 1280 700 magic 0;
#X obj 813 560 ofWindow;
#X obj 39 46 ofSetup;
#X obj 39 368 ofDraw;
#X obj 533 19 declare -lib ofelia;
#X text 36 19 Adaptado do exemplo motion/brownian do [ofelia];
#X msg 647 180 freq \$1;
#X msg 797 180 amp \$1;
#X obj 719 467 sel 0;
#X msg 683 499 destroy;
#X msg 813 530 setPosition 880 0 \, setSize 400 400 \, create;
#X obj 1031 110 loadbang;
#X obj 1031 139 f \$0;
#X obj 766 499 t b b;
#X text 1030 79 inicializações;
#X obj 647 151 r \$0_122C_freq;
#X obj 797 151 r \$0_122C_amp;
#X obj 719 408 r \$0_122C_popup;
#X obj 39 396 spigot;
#X obj 719 437 t f f;
#X text 35 1041 .;
#X obj 681 231 r \$0_122C_harm;
#X text 646 116 recebe variações de freq \, amp \, harm;
#X obj 837 211 r \$0_122C_impar;
#X msg 904 260 impar \$1;
#X obj 681 260 t b f;
#X obj 837 240 t b f;
#X obj 743 19 declare -path ofelia/abs;
#X obj 681 290 ofelia f \; local a=require("\$0-vars3") \; for j=1
\, a.harm do \; a.fase[j] = 0 \; end \;;
#X msg 1031 168 \; \$1_122C_freq_r 0.25 \; \$1_122C_amp_r 0.8 \;;
#X obj 971 290 ofelia f \; local o=require("\$0-vars3") \; if a>0 and
a<=o.harmmax then \; o.harm = a \; end \;;
#X text 391 363 inicia interface;
#X msg 196 365 \; \$1_122C_harm_r \$2;
#X obj 39 85 ofelia f \$0-vars3 \; ofBackground(0) \; ofSetFrameRate(30)
\; M.num \, M.freq \, M.amp \, M.fase \, M.harm \, M.harmmax \, M.N
\, M.sin \, M.impar \, M.proj = 40 \, 1 \, 1 \, ofTable() \, 3 \, 20
\, 30 \, 0 \, 0 \, 0 \; M.ax \, M.ay = ofTable() \, ofTable() \; for
j=1 \, M.harmmax do \; M.fase[j] = 0 \; M.ax[j] \, M.ay[j] = ofTable()
\, ofTable() \; for i=1 \, M.num do \; M.ax[j][i] \, M.ay[j][i] = 300
\, 200 \; end \; end \; return ofTable(\$0 \, M.harm) \;;
#X obj 966 409 r \$0_122C_proj;
#X msg 966 438 proj \$1;
#X obj 39 423 ofelia f \; local a=require("\$0-vars3") \; local function
x2i(x) return 200+math.floor(0.5+100*x) end \; local function y2j(y)
return 200-math.floor(0.5+100*y) end \; for j=1 \, a.harm do for i=2
\, a.num do \; a.ax[j][i-1] \, a.ay[j][i-1] = a.ax[j][i] \, a.ay[j][i]
\; end end \; suma \, sumb = 0 \, 0 \; for j=1 \, a.harm do \; local
k = (a.impar==1 and (2*(j-1)+1)) or j \; suma \, sumb = suma+a.ax[j][1]
\, sumb+a.ay[j][1] \; a.ax[j][a.num] \, a.ay[j][a.num] = a.amp*math.cos(a.fase[j])/k
\, a.amp*math.sin(a.fase[j])/k \; a.fase[j] = a.fase[j]+2*math.pi*k*a.freq/a.N
\; end \; for i=2 \, a.num do \; sumap \, sumbp = suma \, sumb \; suma
\, sumb = 0 \, 0 \; for j=1 \, a.harm do \; ofSetColor((j%3==2 and
1 or 0)*(i)/a.num * 255 \, (j%3==0 and 1 or 0)*(i)/a.num * 255 \, (j%3==1
and 1 or 0)*(i)/a.num * 255) \; ofDrawLine(x2i(suma) \, y2j(sumb) \,
x2i(suma+a.ax[j][i]) \, y2j(sumb+a.ay[j][i])) \; suma \, sumb = suma+a.ax[j][i]
\, sumb+a.ay[j][i] \; end \; ofSetColor(255 \, 255 \, 255) \; ofDrawLine(x2i(sumap)
\, y2j(sumbp) \, x2i(suma) \, y2j(sumb)) \; if a.proj>0 then \; ofSetColor(i/a.num*255
\, i/a.num*255 \, i/a.num*255) \; ofDrawLine(x2i(-1.9+(i-1)/a.num*3.8)
\, y2j(sumbp) \, x2i(-1.9+i/a.num*3.8) \, y2j(sumb)) \; end \; end
\;;
#X f 63;
#X connect 1 0 32 0;
#X connect 2 0 17 0;
#X connect 5 0 32 0;
#X connect 6 0 32 0;
#X connect 7 0 8 0;
#X connect 7 1 12 0;
#X connect 8 0 0 0;
#X connect 9 0 0 0;
#X connect 10 0 11 0;
#X connect 11 0 28 0;
#X connect 12 0 11 0;
#X connect 12 1 9 0;
#X connect 14 0 5 0;
#X connect 15 0 6 0;
#X connect 16 0 18 0;
#X connect 17 0 35 0;
#X connect 18 0 7 0;
#X connect 18 1 17 1;
#X connect 20 0 24 0;
#X connect 22 0 25 0;
#X connect 23 0 32 0;
#X connect 24 0 27 0;
#X connect 24 1 29 0;
#X connect 25 0 27 0;
#X connect 25 1 23 0;
#X connect 32 0 31 0;
#X connect 33 0 34 0;
#X connect 34 0 32 0;
#X restore 501 600 pd magic;
#X obj 151 27 tgl 20 0 \$0_122C_popup empty LIGA 24 10 0 18 -262130
-1 -1 0 1;
#X text 95 27 Hz;
#X obj 151 64 tgl 20 0 \$0_122C_impar \$0_122C_impar_r ímpares 24
10 0 18 -262130 -1 -1 0 1;
#X obj 151 104 tgl 20 0 \$0_122C_proj \$0_122C_proj_r projeta 24 10
0 18 -262130 -1 -1 0 1;
#X coords 0 -1 1 1 260 140 2 0 0;
#X restore 525 148 pd \$0_122C_interface;
#X text 100 144 Veremos que a representação espectral considera COMBINAÇÕES
LINEARES DE EXPONENCIAIS COMPLEXAS \, o que pode ser visualizado no
plano como o acoplamento de movimentos circulares uniformes de frequências
\, amplitudes e fases independentes \, onde cada nova componente possui
um sistema de coordenadas móvel centrado na soma das componentes anteriores
\, como se fossem "engrenagens encaixadas"., f 40;
#X text 220 433 x = exp_f + 0.5*exp_2f + 0.33*exp_3f + ···;
#X text 100 364 A animação dessa página mostra a composição de
uma série harmônica de exponenciais complexas com frequências da
forma k·F0 e amplitudes da forma 1/k. Quando k percorre todos os harmônicos
\, o sinal, f 68;
#X text 220 513 x = exp_f + 0.33*exp_3f + 0.2*exp_5f + ···;
#X text 100 464 possui relação com a forma de onda DENTE-DE-SERRA
\, e quando k varre apenas os harmônicos ímpares \, o sinal, f 68
;
#X text 100 544 tem relação com a forma de onda QUADRADA \, como
é possível constatar visualizando a projeção vertical através
do botão "projeta"., f 68;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 610 600 pd icsm122C;
#N canvas 0 0 1280 700 icsm122B+ 0;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm122B+ vis 1;
#X obj 100 110 cnv 15 14 14 empty empty Identidades_trigonométricas_e_fórmula_de_Euler
0 0 0 28 -262144 -38 0;
#X text 100 150 A fórmula de Euler exp_f = cos_f+i·sen_f e a possibilidade
de expressar funções trigonométricas usando exponenciais complexas
são ferramentas poderosas para simplificar o uso e operacionalização
de propriedades geométricas e trigonométricas. Considere por exemplo
a importante identidade, f 107;
#X text 100 248 (lembre-se que usamos essa identidade para mostrar
a ortogonalidade de senos e cossenos). Usando as expressões complexas
equivalentes \, teremos, f 107;
#X text 210 307 2·cos(a)·cos(b) = 2·(e;
#X text 460 307 + e;
#X text 520 307 )·(e;
#X text 590 307 + e;
#X text 650 307 );
#X text 420 310 __________;
#X text 550 310 __________;
#X text 461 332 2;
#X text 591 332 2;
#X text 430 298 ia;
#X text 490 298 -ia;
#X text 561 298 ib;
#X text 621 298 -ib;
#X text 480 367 + e;
#X text 690 367 + e;
#X text 790 367 );
#X text 591 392 2;
#X text 370 367 = (e;
#X text 410 357 i(a+b);
#X text 510 357 -i(a+b);
#X text 590 367 + e;
#X text 620 357 i(a-b);
#X text 720 357 -i(a-b);
#X text 400 370 _______________________________________;
#X text 410 218 2·cos(a)·cos(b) = cos(a+b) + cos(a-b);
#X text 820 367 = cos(a+b) + cos(a-b).;
#X text 100 428 Analogamente \, podemos ver que, f 107;
#X text 520 467 )·(e;
#X text 650 467 );
#X text 420 470 __________;
#X text 550 470 __________;
#X text 430 458 ia;
#X text 490 458 -ia;
#X text 561 458 ib;
#X text 621 458 -ib;
#X text 490 527 + e;
#X text 800 527 );
#X text 601 552 2;
#X text 420 517 i(a+b);
#X text 520 517 -i(a+b);
#X text 630 517 i(a-b);
#X text 730 517 -i(a-b);
#X text 410 530 _______________________________________;
#X text 210 467 2·sen(a)·sen(b) = 2·(e;
#X text 461 492 2i;
#X text 591 492 2i;
#X text 460 467 - e;
#X text 590 467 - e;
#X text 370 527 = -(e;
#X text 600 527 - e;
#X text 700 527 - e;
#X text 830 527 = cos(a-b) - cos(a+b).;
#X text 6 801 +detalhes(*):;
#X text 100 578 A diferença das duas equações acima \, por exemplo
\, mostra que cos(a+b) = cos(a)·cos(b) - sen(a)·sen(b). Essa é apenas
uma dentre muitas outras propriedades que podem ser verificadas de
maneira análoga \, incluindo derivadas e integrais de funções trigonométricas.
, f 107;
#X connect 0 0 1 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 103 600 pd icsm122B+;
#X text 177 346 cos_f = exp_f+exp_-f;
#X text 517 346 sen_f = exp_f-exp_-f \,;
#X text 257 348 ____________;
#X text 597 348 ____________;
#X text 313 366 2;
#X text 648 366 2i;
#X text 404 531 i2πfn/N+φ;
#X text 514 531 -i2πfn/N-φ;
#X text 436 561 i2πfn/N;
#X text 601 561 -i2πfn/N;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 610 600 pd icsm122B;
#X text 100 514 Na Transformada de Fourier Discreta essas exponenciais
com frequência negativa são imprescindíveis para a correta representação
de sinais complexos arbitrários \, razão pela qual a DFT utiliza
todas as frequências f=0 \, 1 \, ... \, N-1 \, ou equivalentemente
\,, f 69;
#X text 100 332 Exponenciais complexas estão sujeitas ao mesmo limite
de representação de sinais digitais que os sinais reais aos quais
estamos acostumados. Em particular \, a frequência de N/2 ciclos por
bloco fará com que a exponencial percorra meio ciclo a cada amostra
\, o que a fará alternar entre dois valores opostos. A partir de N/2
\, ocorre o fenômeno de REBATIMENTO \, em que componentes com frequências
f>N/2 \, após amostradas \, são indistinguíveis da frequência rebatida
f-N \, que nesse caso será uma FREQUÊNCIA NEGATIVA representando
um movimento circular uniforme EM SENTIDO CONTRÁRIO., f 69;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm122A;
#X obj 324 604 icsm_url https://en.wikipedia.org/wiki/Euler%27s_formula#Using_power_series
;
#X text 100 436 onde a última desigualdade é chamada de FÓRMULA
DE EULER \, e explicita a relação entre exponenciais complexas e
funções trigonométricas. Observe que a última expressão corresponde
à representação cartesiana do ponto x[n]+i·y[n] onde x[n]=cos_f[n]
e y[n]=sen_f[n] \, que é sempre um ponto do círculo de raio unitário
(pois x[n]²+y[n]²=1). Em outras palavras \, exponenciais complexas
mapeiam a expressão da fase φ[n]=2πfn/N em um MOVIMENTO CIRCULAR
UNIFORME que completa exatamente f voltas dentro de um bloco de N amostras.
, f 107;
#X text 100 597 uma prova da fórmula de Euler na Wikipedia:, f 22
;
