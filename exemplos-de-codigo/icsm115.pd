#N canvas 0 0 1280 700 16;
#X obj 0 0 icsm_cabecalho;
#X obj 100 200 cnv 15 14 14 empty empty Amplitude_e_Frequência 0 0
0 34 -262144 -38 0;
#N canvas 0 0 1280 700 icsm115A 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm115A vis 1;
#N canvas 0 0 1280 700 icsm115B 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm115B vis 1;
#X obj 105 206 tgl 24 0 \$0_115_dsp \$0_115_dsp_r DSP 28 12 0 18 -262130
-1 -1 0 1;
#X obj 366 220 hsl 128 20 0 1 0 0 \$0_115B_vol \$0_115B_vol_r Volume_(linear)
-2 -8 0 16 -262144 -1 -1 0 0;
#X obj 696 220 hsl 128 20 0.001 1 1 0 \$0_115B_vol \$0_115B_vol_r Volume_(log)
-2 -8 0 16 -262144 -1 -1 0 0;
#X floatatom 359 421 8 0 0 1 pico #0_115B_bloco_pico -;
#X obj 362 448 hsl 128 20 0 1 0 0 empty empty empty -2 -8 0 16 -262144
-1 -1 0 1;
#X floatatom 359 539 8 0 0 1 RMS #0_115B_bloco_amprms -;
#X obj 362 565 hsl 128 20 0 1 0 0 empty empty empty -2 -8 0 16 -262144
-1 -1 0 1;
#X floatatom 689 481 8 0 0 1 média #0_115B_bloco_energia -;
#X obj 692 507 hsl 128 20 0 1 0 0 empty empty empty -2 -8 0 16 -262144
-1 -1 0 1;
#X floatatom 689 539 8 0 0 1 dB #0_115B_bloco_energiadb -;
#X obj 692 565 hsl 128 20 -65 0 0 0 empty empty empty -2 -8 0 16 -262144
-1 -1 0 1;
#X floatatom 363 244 8 0 1 0 - - -;
#X floatatom 693 244 8 0 1 0 - - -;
#X text 349 219 0;
#X text 679 219 0;
#X text 345 447 0;
#X text 675 506 0;
#X text 345 564 0;
#X text 823 564 0;
#X text 497 219 1;
#X text 827 219 1;
#X text 493 447 1;
#X text 823 506 1;
#X text 493 564 1;
#X obj 100 70 cnv 15 14 14 empty empty Experimento_com_Amplitude 0
0 0 28 -262144 -38 0;
#N canvas 0 0 1280 700 icsm115C 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm115C vis 1;
#X obj 100 90 cnv 15 14 14 empty empty Variação_da_frequência 0
0 0 28 -262144 -38 0;
#N canvas 0 0 1280 700 icsm115D 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm115D vis 1;
#X obj 105 206 tgl 24 0 \$0_115_dsp \$0_115_dsp_r DSP 28 12 0 18 -262130
-1 -1 0 1;
#X obj 321 220 hsl 128 20 0.001 1 1 0 empty \$0_115D_vol_r Volume -2
-8 0 16 -262144 -1 -1 0 0;
#X floatatom 408 394 8 0 0 1 ZCR #0_115D_zcr -;
#X obj 411 507 hsl 256 20 20 20000 0 0 empty empty Frequência_estimada_(linear)
-2 -8 0 16 -262144 -1 -1 0 1;
#X floatatom 318 244 8 0 1 0 - - #0_115D_vol;
#X text 304 219 0;
#X text 452 219 1;
#X obj 100 70 cnv 15 14 14 empty empty Experimento_com_Frequência
0 0 0 28 -262144 -38 0;
#X obj 521 220 hsl 256 20 20 20000 0 0 empty \$0_115D_freq_r Frequência_(linear)
-2 -8 0 16 -262144 -1 -1 0 0;
#X floatatom 518 244 8 20 20000 1 Hz - #0_115D_freq;
#X text 781 218 20k;
#X text 494 219 20;
#X obj 861 220 hsl 256 20 20 20000 1 0 empty \$0_115D_freq_r Frequência_(log)
-2 -8 0 16 -262144 -1 -1 0 0;
#X floatatom 858 244 8 20 20000 1 Hz - #0_115D_freq;
#X text 1121 218 20k;
#X text 834 219 20;
#X text 671 505 20k;
#X text 384 506 20;
#X floatatom 407 579 8 0 0 1 Hz - -;
#X obj 410 550 hsl 256 20 20 20000 1 0 empty empty Frequência_estimada_(log)
-2 -8 0 16 -262144 -1 -1 0 1;
#X text 670 548 20k;
#X text 383 549 20;
#N canvas 0 0 1280 700 icsm115E 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm115E vis 1;
#N canvas 0 0 1280 700 icsm115F 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm115F vis 1;
#N canvas 0 0 1280 700 icsm115G 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm115G vis 1;
#X obj 100 70 cnv 15 14 14 empty empty Frequência_e_Amplitude_revisitadas
0 0 0 28 -262144 -38 0;
#X text 100 110 No experimento de percepção de frequência é possível
observar que o volume percebido de um sinal senoidal de amplitude constante
não é idêntico em todas as frequências. Essa dependência da percepção
de volume em função da frequ6encia em sinais senoidais foi estudada
sistemativamente por FLETCHER e MUNSON na década de 1930 \, e estão
relacionadas com uma escala psicoacústica com unidade PHON. Por definição
\, uma senoide com frequência 1000 Hz possui volume em Phons idêntico
à energia em dB SPL - por exemplo \, uma senoide de 1000 Hz com 40
Phon possui energia de 40 dB SPL. Uma CURVA DE VOLUME CONSTANTE (Equal
Loudness Curve) em X Phons é construída ajustando a energia de senoides
de frequências diferentes de tal modo que aparentem possuir o mesmo
volume perceptual que a senoide original de 1000 Hz com X dB SPL. O
modelo de Fletcher e Munson foi revisado por Robinson e Dadson na década
de 1950 \, dando origem às curvas ISO 226:2003 ilustradas abaixo.
, f 107;
#X text 100 300 Outra escala psicoacústica relevante para a percepção
de volume é a escala de SONES \, que é definida para tons puros em
1000 Hz como 1 Sone = 40 Phons e cada aumento de 10 Phons corresponde
aproximadamente a dobrar o valor em Sones (portanto 2 Sones = 50 Phons
\, 4 Sones = 60 Phons \, etc)., f 83;
#X obj 1083 423 image icsm115_phons.ppm;
#N canvas 0 0 1280 700 icsm115H 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm115H vis 1;
#X obj 100 70 cnv 15 14 14 empty empty Experimento_com_Compensação_de_Amplitude
0 0 0 28 -262144 -38 0;
#N canvas 0 0 450 250 (subpatch) 0;
#X array RAf_\$0 1024 float 2;
#X coords 0 1 1024 0 400 280 1 0 0;
#X restore 412 352 graph;
#X obj 394 261 hsl 256 20 20 20000 1 0 empty \$0_115H_freq_r Frequência
-2 -8 0 16 -262144 -1 -1 0 1;
#X floatatom 391 292 8 20 20000 1 Hz - #0_115H_freq;
#X text 654 259 20k;
#X text 367 260 20;
#X obj 644 835 t f f;
#X obj 644 864 expr 20*pow(10 \, 3*$f1/1024);
#X obj 401 863 ofelia f \; local x=ofOutlet(this) \; for i=0 \, 1023
do \; x:outletFloat(0 \, i) \; end;
#X obj 644 894 expr pow(12194 \, 2)*pow($f1 \, 4)/((pow($f1 \, 2)+pow(20.6
\, 2))*sqrt((pow($f1 \, 2)+pow(107.7 \, 2))*(pow($f1 \, 2)+pow(737.9
\, 2)))*(pow($f1 \, 2)+pow(12194 \, 2))) \; int(1024*log10($f1/20)/3)
;
#X obj 145 256 tgl 24 0 \$0_115_dsp \$0_115_dsp_r DSP 28 12 0 18 -262130
-1 -1 0 1;
#X obj 235 256 tgl 24 0 \$0_115H_mute \$0_115H_mute_r MUTE 28 12 0
18 -262130 -1 -1 0 1;
#X obj 740 256 tgl 24 0 \$0_115H_A empty Liga/Desliga_compensação_(A-weighting)
28 12 0 18 -262130 -1 -1 0 1;
#X obj 644 983 tabwrite RAf_\$0;
#X obj 401 833 loadbang;
#X text 709 835 Preenche a tabela com os valores da fórmula;
#N canvas 0 0 503 346 \$0_115H_síntese 0;
#X obj 82 211 expr 1-$f1;
#X obj 75 244 *~ 1;
#X obj 75 144 *~ 0;
#X obj 75 283 dac~;
#X obj 263 51 r \$0_115_dsp;
#X obj 102 116 r \$0_115H_vol;
#X obj 76 51 r \$0_115H_freq;
#X obj 76 83 osc~;
#X obj 263 103 sel 0;
#X msg 310 132 \; pd dsp 1;
#X obj 263 132 f \$0;
#X obj 82 182 r \$0_115H_mute;
#X msg 263 186 \; \$1_115H_freq_r 0 \; pd dsp 0;
#X connect 0 0 1 1;
#X connect 1 0 3 0;
#X connect 1 0 3 1;
#X connect 2 0 1 0;
#X connect 4 0 8 0;
#X connect 5 0 2 1;
#X connect 6 0 7 0;
#X connect 7 0 2 0;
#X connect 8 0 10 0;
#X connect 8 1 9 0;
#X connect 10 0 12 0;
#X connect 11 0 0 0;
#X restore 103 315 pd \$0_115H_síntese;
#X obj 415 632 hsl 395 20 20 20000 1 0 empty \$0_115H_freq Frequência_(log)
240 35 0 16 -262144 -1 -1 0 1;
#X obj 392 354 vsl 20 274 0 1 0 0 empty \$0_115H_RAf empty 0 -9 0 16
-262144 -1 -1 66 1;
#X obj 812 354 vsl 20 274 0 0.1 0 0 empty \$0_115H_vol Vol 0 -12 0
16 -262144 -1 -1 2730 1;
#N canvas 0 0 705 460 \$0_115H_amplitude 0;
#X obj 51 401 s \$0_115H_vol;
#X obj 51 119 expr int(1024*log10($f1/20)/3);
#X obj 93 367 zexy;
#X obj 51 367 mux;
#X obj 158 289 r \$0_115H_A;
#X obj 298 255 s \$0_115H_RAf;
#X obj 51 185 expr 0.01 \; min(1 \, 0.01/RAf_\$0[$f1]) \; RAf_\$0[$f1]
;
#X text 365 119 converte frequência em índice do gráfico R_A(f)
, f 24;
#X text 319 183 0.01 é a amplitude não compensada;
#X text 319 204 a compensação é feita por divisão;
#X text 319 225 valor enviado para o gráfico;
#X obj 51 13 r \$0_115H_freq;
#X obj 51 82 f;
#X obj 158 318 t b f;
#X obj 158 351 s \$0_115H_recalc;
#X obj 68 51 r \$0_115H_recalc;
#X connect 1 0 6 0;
#X connect 3 0 0 0;
#X connect 4 0 13 0;
#X connect 6 0 3 0;
#X connect 6 1 3 1;
#X connect 6 2 5 0;
#X connect 11 0 12 0;
#X connect 12 0 1 0;
#X connect 13 0 14 0;
#X connect 13 1 3 2;
#X connect 15 0 12 0;
#X restore 103 354 pd \$0_115H_amplitude;
#X text 216 487 este é o valor -> da função R_A(f), f 17;
#X text 835 487 <- aqui aparece o volume compensado (aplicado no sinal)
, f 31;
#X text 396 804 Fórmula: R_A(f) = 12194^2f^4/((f^2+20.6^2)sqrt((f^2+107.7^2)(f^2+737.9^2))(f^2+12194^2)
, f 88;
#X text 100 100 Nesse experimento você poderá testar o efeito da
compensação de amplitude conhecida como A-weighting \, definida na
norma IEC 61672:2003 e ilustrada pela função R_A(f) abaixo. Esses
valores corresponderiam simplificadamente à amplitude relativa percebida
pelo ouvido em função da frequência \, e a compensação é feita
pela divisão da amplitude do oscilador pela função R_A(f). Essa
curva tem por referência o valor de 40 phons \, que é um volume relativamente
baixo \, então a aderência do modelo depende também de um ajuste
baixo do volume do fone-de-ouvido ou alto-falante., f 107;
#X connect 1 0 2 0;
#X connect 5 0 6 0;
#X connect 9 0 10 0;
#X connect 9 1 16 1;
#X connect 10 0 12 0;
#X connect 11 0 9 0;
#X connect 12 0 16 0;
#X connect 17 0 11 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm115H;
#X text 918 563 Imagens: Wikimedia Commons;
#X obj 776 470 image icsm115_cochlea.ppm;
#X text 100 377 Para se medir o volume em Sones de misturas de fontes
sonoras diferentes \, o cálculo é mais complicado. Se dois tons senoidais
são muito próximos \, caindo em uma mesma BANDA CRÍTICA (faixa de
alturas detectadas pelo mesmo ÓRGÃO DE CORTI na CÓCLEA) \, suas
energias se somam. Se estiverem em bandas críticas diferentes \, são
os volumes em Sones que se somam. E se as distâncias entre as bandas
críticas ou entre os níveis de volume forem muito grandes \, pode
ocorrer o efeito de MASCARAMENTO \, onde o volume percebido é simplesmente
o máximo dentre os volumes individuais., f 51;
#N canvas 0 0 1280 700 icsm115G+ 0;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm115G+ vis 1;
#X text 6 801 +detalhes(*):;
#N canvas 0 0 920 419 \$0_fletcher_munson 0;
#X obj 56 186 bng 24 250 50 0 \$0_115G+_aceita_vol empty Aceita_volume
28 12 0 16 -262130 -1 -1;
#X obj 56 324 bng 24 250 50 0 \$0_115G+_init empty Reinicializa_experimento
28 12 0 16 -262130 -1 -1;
#N canvas 0 0 974 709 mágica 0;
#X msg 222 544 init;
#X obj 47 256 osc~ 1000;
#X obj 102 516 dac~;
#X obj 326 387 *~ 0.01;
#X obj 326 352 osc~;
#X obj 405 499 pack f f f;
#X obj 405 529 route 0;
#X obj 326 166 random 1000;
#X obj 326 201 + 12;
#X obj 326 236 expr 20*pow(1000 \, $f1/1024);
#X obj 365 612 ofelia d \; \; local data=ofTable() \; local A=ofArray("\$0_A")
\; \; function ofelia.init() \; data=ofTable() \; data[1] = ofTable(20
\, 0) \; data[2] = ofTable(1000 \, 20*math.log(0.01)/math.log(10))
\; data[3] = ofTable(20000 \, 0) \; ofelia.bang() \; end \; \; local
function f2i(f) return math.floor(1024*math.log(f/20)/math.log(1000))
end \; \; local function i2f(i) return 20*1000^(i/1024) end \; \; function
ofelia.list(a) \; local N=#data+1 \; a[2] = 20*math.log(a[2])/math.log(10)
\; local i=1 \; while data[i][1]<a[1] do i = i+1 end \; for j=N \,
i+1 \, -1 do data[j]=data[j-1] end \; data[i]=a \; ofelia.bang() \;
end \; \; function ofelia.bang() \; for i=1 \, #data-1 do \; local
i1=f2i(data[i][1]) \; local i2=f2i(data[i+1][1]) \; if i2>i1 then for
j=i1 \, i2-1 do \; A[j]=data[i][2]+(data[i+1][2]-data[i][2])*(j-i1)/(i2-i1)
\; end end \; end \; end \;;
#X obj 459 277 r \$0_115G+_vol;
#X obj 222 485 r \$0_115G+_init;
#X obj 326 83 r \$0_115G+_freq;
#X obj 405 428 r \$0_115G+_aceita_vol;
#X text 47 182 Oscilador fixo em 1000 Hz com volume 0.01, f 14;
#X text 491 83 sorteia frequência nova;
#X text 452 166 índices entre 12 e 1011 (exclui extremos da tabela
\, que tem 1024 pontos), f 33;
#X text 606 277 recebe valor de volume;
#X text 519 498 cria mensagem da forma |freq vol<;
#X obj 74 286 r \$0_115G+_dsp;
#X obj 94 410 s \$0_115_dsp;
#X obj 47 473 *~;
#X obj 74 438 * 0.01;
#X obj 114 380 s \$0_115G+_init;
#X obj 326 312 t f f;
#X obj 405 558 t l b;
#X obj 222 514 t b b;
#X obj 74 315 t f f b;
#X obj 107 620 f \$0;
#X obj 326 112 t b b;
#X obj 388 112 f \$0;
#X msg 444 112 \; \$1_115G+_vol_r 0 \;;
#X msg 107 655 \; \$1_115G+_freq bang \;;
#X text 479 463 não aceita vol=0 (-infty dB);
#X obj 405 462 spigot;
#X obj 459 337 t f f f;
#X text 45 22 A discussão dessa implementação não faz parte do
conteúdo \, entre por sua conta e risco...;
#X connect 0 0 10 0;
#X connect 1 0 22 0;
#X connect 3 0 2 1;
#X connect 3 0 2 0;
#X connect 4 0 3 0;
#X connect 5 0 6 0;
#X connect 6 0 26 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 9 0 25 0;
#X connect 11 0 36 0;
#X connect 12 0 27 0;
#X connect 13 0 30 0;
#X connect 14 0 35 0;
#X connect 20 0 28 0;
#X connect 22 0 2 1;
#X connect 22 0 2 0;
#X connect 23 0 22 1;
#X connect 25 0 4 0;
#X connect 25 1 5 1;
#X connect 26 0 10 0;
#X connect 26 1 29 0;
#X connect 27 0 0 0;
#X connect 27 1 29 0;
#X connect 28 0 23 0;
#X connect 28 1 21 0;
#X connect 28 2 24 0;
#X connect 29 0 33 0;
#X connect 30 0 7 0;
#X connect 30 1 31 0;
#X connect 31 0 32 0;
#X connect 35 0 5 0;
#X connect 36 0 3 1;
#X connect 36 1 5 2;
#X connect 36 2 35 1;
#X restore 617 761 pd mágica;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_A 1024 float 2;
#X coords 0 0 1024 -50 400 280 1 0 0;
#X restore 423 52 graph;
#X text 410 334 20Hz;
#X text 800 334 20kHz;
#X text 619 334 1000Hz;
#X text 389 316 -50;
#X text 389 256 -40;
#X text 389 203 -30;
#X text 389 150 -20;
#X text 389 97 -10;
#X text 369 44 dB: 0;
#X obj 56 44 tgl 24 0 \$0_115G+_dsp empty LIGA/DESLIGA_EXPERIMENTO
28 12 0 18 -262130 -1 -1 0 1;
#X obj 56 254 bng 24 250 50 0 \$0_115G+_freq empty Nova_frequência
28 12 0 16 -262130 -1 -1;
#X obj 59 118 hsl 200 20 0.0001 1 1 0 \$0_115G+_vol \$0_115G+_vol_r
Volume 0 -12 0 16 -262144 -1 -1 0 1;
#X coords 0 -1 1 1 900 400 2 0 0;
#X restore 179 255 pd \$0_fletcher_munson;
#X obj 100 70 cnv 15 14 14 empty empty Experimento_de_Fletcher-Munson_simplificado
0 0 0 28 -262144 -38 0;
#X text 100 110 Nesse patch você poderá construir uma curva de volume
igual personalizada com uma versão simplificada do experimento de
Fletcher-Munson. Você escutará sempre dois tons senoidais \, sendo
um deles de 1000 Hz e outro de uma frequência aleatória. Encontre
um volume que "equilibre" perceptualmente os dois tons \, fazendo com
que você não perceba nenhum deles como mais forte do que o outro
\, e marque a opção "Aceita_volume". A qualquer momento você pode
apertar "Nova frequência" para pular algum tom que esteja difícil
de equilibrar. Se o gráfico com os ajustes perceptuais ficar muito
bagunçado ou errado \, clique em "Reinicializar experimento" e comece
de novo., f 107;
#X connect 0 0 1 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 657 609 pd icsm115G+;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm115G;
#X obj 100 70 cnv 15 14 14 empty empty Experimento_com_Intervalos_Musicais
0 0 0 28 -262144 -38 0;
#X obj 103 246 tgl 24 0 \$0_115_dsp \$0_115_dsp_r DSP 28 12 0 18 -262130
-1 -1 0 1;
#X obj 319 256 hsl 128 20 0.0001 1 1 0 empty \$0_115F_vol_r Volume
-2 -8 0 16 -262144 -1 -1 0 0;
#X floatatom 316 280 8 0 1 0 - - #0_115F_vol;
#X text 302 255 0;
#X text 450 255 1;
#X obj 193 246 tgl 24 0 \$0_115F_mute \$0_115F_mute_r MUTE 28 12 0
18 -262130 -1 -1 0 1;
#X obj 649 256 hsl 256 20 20 20000 1 0 empty \$0_115F_F0_r Frequência_F0
-2 -8 0 16 -262144 -1 -1 0 0;
#X floatatom 646 280 8 20 20000 1 Hz - #0_115F_F0;
#X text 909 254 20k;
#X text 622 255 20;
#X msg 975 262 2;
#X msg 975 292 1.5;
#X msg 975 322 1.25;
#X msg 975 352 1.05946;
#X text 1076 322 (terça);
#X text 1076 352 (semitom);
#X text 1076 292 (quinta);
#X text 1076 262 (oitava);
#X floatatom 646 551 8 0 0 1 Hz - #0_115F_freq;
#X floatatom 508 256 5 0 60 2 Passos_(N) #0_115F_N_r #0_115F_N;
#X obj 649 522 hsl 256 20 20 20000 1 0 empty empty Frequência_escutada_(log)
-2 -8 0 16 -262144 -1 -1 0 1;
#X text 909 520 20k;
#X text 622 521 20;
#X text 974 242 Razão (R);
#X text 595 591 <- observe que as PGs em escala log "viram" PAs.,
f 25;
#N canvas 0 0 1009 738 \$0_computa_frequência 0;
#X text 36 34 Esse patch computa a frequência da forma F0*R^N sempre
que um desses parâmetros é alterado na interface correspondente.
O objeto principal é o [expr $f2*pow($f3 \, $f1)] \, e o conceito
novo é a ideia de inlets QUENTES e FRIOS., f 87;
#X obj 129 262 expr $f2*pow($f3 \, $f1);
#X obj 296 148 t b f;
#X obj 475 148 t b f;
#X text 36 334 A necessidade do sequenciamento de ações representado
pelos objetos [trigger bang float] tem origem no fato de que o objeto
[expr] utilizado possui 3 inlets \, sendo que em Pd apenas o inlet
mais à esquerda provoca o cálculo da expressão (no jargão Pd esse
é o inlet "quente" \, sendo os demais "frios" \, ou seja \, recebem
valores mas não produzem saída). A ideia de inlets quentes e frios
é muito útil para sincronizar cálculos que dependem de entradas
que não estão disponíveis simultaneamente \, oferecendo maior controle
temporal sobre o instante exato em que as expressões são calculadas
\, que é o instante em que o inlet quente é acionado. Observe que
a convenção de inlets quentes mais à esquerda explica a convenção
de que as saídas dos objetos são disponibilizadas sempre da direita
para a esquerda., f 87;
#X text 36 544 No exemplo acima \, o objeto [expr] apenas produzirá
o resultado quando receber o valor correspondente ao parâmetro $f1
\, no nosso caso o N (mas podíamos ter escolhido os parâmetros em
qualquer ordem). A cada vez que um valor de F0 for recebido \, esse
valor será repassado pelo [trigger] para a 2a entrada do [expr] \,
e em seguida um bang no inlet quente do [expr] fará a expressão ser
calculada com o último valor recebido no lugar de $f1 (esses parâmetros
funcionam como MEMÓRIAS ou variáveis internas ao objeto). O mesmo
comportamento será observado quando um novo valor de R for recebido.
, f 87;
#X obj 129 291 outlet;
#X obj 129 119 r \$0_115F_N;
#X obj 296 119 r \$0_115F_F0;
#X obj 475 119 r \$0_115F_R;
#X connect 1 0 6 0;
#X connect 2 0 1 0;
#X connect 2 1 1 1;
#X connect 3 0 1 0;
#X connect 3 1 1 2;
#X connect 7 0 1 0;
#X connect 8 0 2 0;
#X connect 9 0 3 0;
#X restore 646 388 pd \$0_computa_frequência;
#X text 644 361 Calcula a expressão F0*R^N:;
#X obj 975 404 nbx 5 20 1 4 0 1 \$0_115F_R \$0_115F_R_r Tamanho_do_Passo
0 -8 0 16 -262144 -1 -1 1 256;
#N canvas 0 0 664 603 \$0_115F_escala 0;
#X obj 98 214 t b f;
#X obj 68 155 r \$0_115F_F0;
#X obj 98 185 r \$0_115F_R;
#X text 63 38 Representa graficamente os valores de frequência F0*R^N
associados aos passos da "escala" N=0 \, 1 \, 2 \, ..., f 47;
#X obj 68 245 pack f f;
#X obj 68 289 ofelia f \; x = ofArray("\$0_115F_frequências") \; --[[
calcula maior passo "audível" ]] \; if a[2]==1 then N=20 \; else N
= math.min(20 \, math.floor(1+math.log(20000/a[1])/math.log(a[2])))
\; end \; --[[ computa as frequências dos passos audíveis ]] \; for
n = 0 \, N-1 do \; x[n] = math.log(a[1]*a[2]^n) \; end \; --[[ preenche
o resto da tabela com o valor máximo ]] \; for n = N \, 19 do \; x[n]
= math.log(20000) \; end \;;
#X connect 0 0 4 0;
#X connect 0 1 4 1;
#X connect 1 0 4 0;
#X connect 2 0 0 0;
#X connect 4 0 5 0;
#X restore 308 332 pd \$0_115F_escala;
#N canvas 0 0 487 338 \$0_115F_síntese 0;
#X obj 72 191 expr 1-$f1;
#X obj 65 224 *~ 1;
#X obj 65 124 *~ 0;
#X obj 66 31 r \$0_115F_freq;
#X obj 92 96 r \$0_115F_vol;
#X obj 66 63 osc~ 400;
#X obj 65 263 dac~;
#X obj 245 32 r \$0_115_dsp;
#X obj 245 61 sel 0;
#X obj 245 90 f \$0;
#X msg 331 72 \; pd dsp 1;
#X obj 72 162 r \$0_115F_mute;
#X msg 245 121 \; \$1_115F_vol_r 0 \; \$1_115F_N_r 0 \; \$1_115F_F0_r
0 \; \$1_115F_R_r 1 \; pd dsp 0;
#X connect 0 0 1 1;
#X connect 1 0 6 0;
#X connect 1 0 6 1;
#X connect 2 0 1 0;
#X connect 3 0 5 0;
#X connect 4 0 2 1;
#X connect 5 0 2 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 8 1 10 0;
#X connect 9 0 12 0;
#X connect 11 0 0 0;
#X restore 105 332 pd \$0_115F_síntese;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_115F_frequências 20 float 2;
#X coords 0 10 20 3 400 200 1 0 1;
#X restore 185 413 graph;
#X text 111 633 Passos:;
#X text 188 633 0;
#X text 208 633 1;
#X text 228 633 2;
#X text 248 633 3;
#X text 268 633 4;
#X text 288 633 5;
#X text 308 633 6;
#X text 328 633 7;
#X text 348 633 8;
#X text 368 633 9;
#X text 384 633 10;
#X text 405 633 ...;
#X obj 646 417 min 20000;
#X text 746 419 limita às freqs audíveis, f 14;
#X text 100 110 Esse experimento visa ilustrar a ideia de INTERVALOS
MUSICAIS \, que correspondem a razões entre frequências. Outra maneira
de compreender que nosso ouvido "percebe" o log da frequência é observar
que razões iguais entre frequências são percebidas como passos iguais
no "espaço perceptual" das alturas musicais. Escolha uma frequência
F0 de base e uma razão R (passo multiplicativo) \, e observe como
seu ouvido percebe as progressões geométricas de frequências da
forma F0*R^N para N=0 \, 1 \, 2 \, ... \, que formam ESCALAS (ou seja
\, escadas) no gráfico abaixo., f 107;
#X text 141 443 5k;
#X text 131 422 10k;
#X text 131 401 20k;
#X text 121 470 2000;
#X text 121 490 1000;
#X text 131 510 500;
#X text 131 536 200;
#X text 131 556 100;
#X text 141 575 50;
#X text 141 601 20;
#X obj 185 613 hradio 20 1 0 20 \$0_115F_N \$0_115F_N_r empty 0 -8
0 10 -262144 -1 -1 0;
#X obj 165 415 vsl 20 198 20 20000 1 0 empty \$0_115F_freq empty 0
-9 0 10 -262144 -1 -1 0 1;
#X connect 1 0 2 0;
#X connect 6 0 7 0;
#X connect 11 0 12 0;
#X connect 15 0 32 0;
#X connect 16 0 32 0;
#X connect 17 0 32 0;
#X connect 18 0 32 0;
#X connect 25 0 23 0;
#X connect 30 0 49 0;
#X connect 49 0 25 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm115F;
#X obj 100 70 cnv 15 14 14 empty empty Altura_Musical_e_Intervalos_Musicais
0 0 0 28 -262144 -38 0;
#X text 100 110 O termo ALTURA MUSICAL designa a posição de um som
periódico ou quase periódico no eixo perceptual associado aos termos
GRAVE e AGUDO. Esse eixo possui uma relação com o eixo dos valores
de frequências audíveis \, entre 20 Hz e 20 kHz \, porém as variações
na percepção de altura possuem uma relação não-linear com as variações
nos valores de frequências. Em outras palavras \, "passos" ou "deslocamentos"
iguais em um desses eixos não corresponderão a passos/deslocamentos
iguais no outro., f 107;
#X text 100 210 Grosseiramente falando \, ocorre com a altura musical
um fenômeno parecido com o que observamos em relação à amplitude
\, onde a resposta do ouvido estava relacionada aproximadamente com
o logaritmo do parâmetro físico correspondente. Assim \, RAZÕES
ENTRE FREQUÊNCIAS do tipo R=F1/F0 serão mapeadas através do log
em DIFERENÇAS do tipo log(R) = log(F1)-log(F0) \, de tal modo que
o deslocamento percebido entre as frequências F0 e F1 será semelhante
ao deslocamento entre F1 e F2=R*F1 (pois log(F2/F1)=log(R)) \, ou entre
F2 e F3=R*F2 e assim por diante. Pode-se obter uma ESCALA DE PASSOS
PERCEPTUAIS IGUAIS construindo-se PROGRESSÕES GEOMÉTRICAS da forma
F0 \, R*F0 \, R²*F0 \, R³*F0 \, e assim por diante. RAZÕES INVERSAS
representam simplesmente passos na direção contrária \, pois se
F1=R*F0 então F0=(1/R)*F1., f 107;
#X text 100 370 Algumas razões específicas entre frequências possuem
um espaço de destaque devido a uma série de propriedades físicas
\, matemáticas e perceptuais. A razão R=2 recebeu o nome de OITAVA
por motivos históricos \, pois a partir de uma altura musical associada
a uma frequência inicial F0 se atingia a frequência 2*F0 como o oitavo
passo em uma escala musical chamada de DIATÔNICA. Sons cujas frequências
são relacionadas por oitavas são percebidos como tão similares que
musicalmente recebem os mesmos nomes: por exemplo \, as alturas denotadas
por A1 \, A2 \, A3 e A4 são todas chamadas de LÁ \, e estão convencionalmente
associadas às frequências A1=55 Hz \, A2=110 Hz \, A3=220 Hz e A4=440
Hz. Outras razões simples \, como 3/2 e 5/4 \, já faziam parte da
teoria musical na época de PITÁGORAS \, sendo (hoje) chamadas de
QUINTA JUSTA e TERÇA MAIOR (esses nomes também estão relacionados
com a escala diatônica). Um intervalo musicalmente importante é o
SEMITOM (em um sistema chamado TEMPERAMENTO IGUAL) \, que divide a
oitava em 12 intervalos iguais \, ou seja \, que satisfaz a equação
R¹²=2 \, e portanto R=2^(1/12)~1.05946. A escala musical correspondente
a essa razão é chamada de ESCALA CROMÁTICA., f 107;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm115E;
#X text 383 579 F0;
#X text 406 350 Observe aqui os valores de frequência instantânea
(F0) estimados pelo ZCR:, f 38;
#X obj 408 450 expr ($f1/2)*44100/64;
#X obj 195 206 tgl 24 0 \$0_115D_mute \$0_115D_mute_r MUTE 28 12 0
18 -262130 -1 -1 0 1;
#X text 100 110 Nesse experimento controlaremos a frequência de um
sinal elementar a fim de observarmos como nossa percepção se comporta
em relação à variação desse parâmetro. Use os dois controles
deslizantes \, com distribuições linear e logarítmica na frequência
\, e preste atenção à sua percepção de altura musical (grave/agudo).
Qual controle parece corresponder melhor à sua percepção?, f 107
;
#X obj 105 276 vradio 24 1 1 4 \$0_115D_mux \$0_115D_mux_r empty 0
-8 0 10 -262130 -1 -1 0;
#X text 137 276 SILÊNCIO;
#X text 137 302 SENOIDE;
#X text 137 327 DENTE-DE-SERRA;
#X text 137 350 QUADRADA;
#N canvas 0 0 523 551 \$0_115D_síntese 0;
#X obj 46 473 outlet~;
#X obj 255 389 zexy;
#X obj 223 358 sgn~;
#X obj 45 444 *~ 0;
#X obj 163 298 *~ 2;
#X obj 163 328 -~ 1;
#X obj 45 145 r \$0_115D_mux;
#X text 42 24 Esse subpatch \, quase idêntico ao do subpatch icsm115B
\, realiza a síntese de várias formas de onda periódicas \, como
visto na seção SINAIS ELEMENTARES., f 42;
#X obj 45 389 multiplex~ 0 1 2 3;
#X obj 82 416 r \$0_115D_vol;
#X obj 104 206 t f f;
#X obj 104 239 osc~;
#X obj 163 269 phasor~;
#X obj 104 177 r \$0_115D_freq;
#X connect 2 0 8 3;
#X connect 3 0 0 0;
#X connect 4 0 5 0;
#X connect 5 0 2 0;
#X connect 5 0 8 2;
#X connect 6 0 8 0;
#X connect 8 0 3 0;
#X connect 9 0 3 1;
#X connect 10 0 11 0;
#X connect 10 1 12 0;
#X connect 11 0 8 1;
#X connect 12 0 4 0;
#X connect 13 0 10 0;
#X restore 105 471 pd \$0_115D_síntese;
#N canvas 0 0 670 404 \$0_115D_dac 0;
#X obj 55 255 dac~;
#X obj 55 215 *~ 1;
#X text 409 101 controle liga/desliga;
#X text 90 90 controle mute;
#X obj 55 54 inlet~;
#X text 129 54 recebe sinal sintetizado;
#X obj 92 152 * -1;
#X obj 92 181 + 1;
#X text 145 150 (inverte valor do mute);
#X obj 409 134 r \$0_115_dsp;
#X obj 143 197 loadbang;
#X obj 143 255 tabwrite~ \$0_115D_sinal;
#X obj 143 226 metro 100 64 samp;
#X obj 409 167 sel 0;
#X msg 456 196 \; pd dsp 1;
#X obj 409 196 f \$0;
#X obj 92 123 r \$0_115D_mute;
#X msg 409 250 \; \$1_115D_vol_r 0 \; \$1_115D_mux_r 0 \; \$1_115D_freq_r
0 \; pd dsp 0;
#X connect 1 0 0 0;
#X connect 1 0 0 1;
#X connect 4 0 1 0;
#X connect 4 0 11 0;
#X connect 6 0 7 0;
#X connect 7 0 1 1;
#X connect 9 0 13 0;
#X connect 10 0 12 0;
#X connect 12 0 11 0;
#X connect 13 0 15 0;
#X connect 13 1 14 0;
#X connect 15 0 17 0;
#X connect 16 0 6 0;
#X restore 104 558 pd \$0_115D_dac;
#N canvas 0 0 521 342 \$0_115D_análise 0;
#X obj 47 99 inlet~;
#X text 44 10 Conta a quantidade de vezes que amostras sucessivas dentro
de um mesmo bloco trocam de sinal., f 39;
#X obj 48 132 ofelia f -s10 \; local sendzcr = ofSend("\$0_115D_zcr")
\; local zcr = 0 \; for i = 1 \, #a1-1 do \; if a1[i]*a1[i+1]<0 then
\; zcr = zcr+1 \; end \; end \; sendzcr:sendFloat(zcr) \;;
#X connect 0 0 2 0;
#X restore 152 513 pd \$0_115D_análise;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_115D_sinal 882 float 0;
#X coords 0 1.1 881 -1.1 300 180 1 0 0;
#X restore 880 393 graph;
#N canvas 0 0 630 473 icsm115D+ 0;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm115D+ vis 1;
#X text 33 121 O experimento \, por outro lado \, envolve elementos
bastante complexos \, tanto perceptuais quanto matemáticos \, e que
merecem ser observados:, f 50;
#X text 93 201 (1) observe como sua percepção lida com o parâmetro
perceptual de AMPLITUDE enquanto você varia a frequência. Essa observação
tem relação com o experimento que relaciona amplitude e frequência
\, ainda nesta seção., f 44;
#X text 93 311 (2) observe o que acontece com os sinais dente-de-serra
e quadrado quando você vai para as frequências mais altas/agudas.
Esses (d)efeitos tem relação com o fenômeno do REBATIMENTO \, abordado
na próxima seção., f 44;
#X text 6 801 comentários:;
#X text 33 21 Essa implementação é substancialmente mais simples
do que a anterior \, sendo que o único objeto novo é o [expr] \,
uma calculadora poderosa com um patch de Ajuda bastante detalhado e
que merece ser lido., f 50;
#X connect 0 0 1 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 106 407 pd icsm115D+;
#X connect 1 0 2 0;
#X connect 4 0 7 0;
#X connect 5 0 28 0;
#X connect 6 0 22 0;
#X connect 11 0 12 0;
#X connect 15 0 16 0;
#X connect 22 0 21 0;
#X connect 28 0 6 0;
#X connect 36 0 37 0;
#X connect 36 0 38 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm115D;
#X text 100 150 Como vimos anteriormente \, a FREQUÊNCIA de um sinal
periódico (como uma SENOIDE) é definida como o inverso do PERÍODO
\, que por sua vez é o menor valor de τ>0 para o qual x(t+τ)=x(t)
para qualquer t. Para sinais "quase" periódicos é possível definir
uma FREQUÊNCIA APROXIMADA considerando a equação acima também de
forma aproximada (formalmente seria necessário considerar a minimização
do erro absoluto e(t)=|x(t+τ)=x(t)|). Para sinais que não sejam periódicos
ainda é possível definir uma FREQUÊNCIA INSTANTÂNEA considerando
a frequência aproximada obtida em uma JANELA TEMPORAL pequena (por
exemplo \, de alguns milissegundos). Estimar precisamente a frequência
instantânea não é uma tarefa trivial \, e será discutida em detalhes
no capítulo sobre ANÁLISE., f 107;
#X text 100 340 Um estimador BASTANTE IMPRECISO (mas simples) para
a frequência de um sinal senoidal pode ser obtido contabilizando-se
a quantidade de trocas de sinal (positivo->negativo e vice-versa) do
sinal sonoro por segundo. Como o sinal senoidal cruza o eixo horizontal
exatamente 2 vezes por período \, sua frequência pode ser estimada
como a metade da TAXA DE CRUZAMENTOS POR ZERO (ZCR = Zero-Crossing
Rate). Essa é uma medida cuja precisão depende do horizonte de tempo
considerado \, e será tanto mais imprecisa quanto menor a janela de
observação \, particularmente para frequências baixas (que possuem
períodos altos). Uma senoide de 20 Hz por exemplo terá um período
de 1/20 = 0.05 segundos ou 50 milissegundos \, o que corresponde a
mais de 34 blocos DSP do Pd com a configuração default. Em particular
\, qualquer frequência menor do que 44100/64 = 689 Hz não poderá
sequer completar 1 período dentro de 1 bloco DSP (isso explica por
exemplo que no experimento anterior as amplitudes dos sinais em blocos
de 64 amostras flutuassem tanto)., f 107;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1001 600 pd icsm115C;
#N canvas 0 0 1280 700 icsm115B+ 0;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm115B+ vis 1;
#X text 6 801 comentários:;
#X text 37 76 Sends/Receives são utilizados para enviar mensagens
entre objetos sem a necessidade de criar conexões visíveis. um [send
IDENTIFICADOR] (ou de forma abreviada [s IDENTIFICADOR]) enviará qualquer
dado que chegue ao seu inlet para quaisquer receptores [receive IDENTIFICADOR]
ou [r IDENTIFICADOR]. Isso é importante em diversos contextos: para
permitir a troca de mensagens entre objetos que não estão no mesmo
patch ou subpatch \, para diminuir a poluição visual associada a
conexões entre objetos distantes e para deixar mais limpas as interfaces
gráficas \, como chaves [toggle] \, botões [bng] e controles deslizantes
[hslider]/[vslider] \, que podem receber ou enviar diretamente informações
de outros pontos do patch (os sends/receives associados às interfaces
gráficas são acessíveis no respectivo menu "Propriedades")., f
119;
#X text 37 11 Esta implementação reutiliza vários objetos já vistos
\, mas traz uma interface gráfica nova (controle deslizante horizontal
ou [hslider]) \, um exemplo de uso de códigos em Lua armazenados em
arquivos externos \, e dois mecanismos importantíssimos da linguagem
Pd: o uso de objetos [send]/[receive] e os objetos [trigger] \, [delay]
e [metro]., f 119;
#X obj 129 435 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 129 455 ofelia f \; x=0;
#X obj 239 435 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 239 455 ofelia f \; x=x+1;
#X obj 339 455 ofelia f \; x=2*x;
#X obj 449 435 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 449 455 ofelia f \; return x;
#X floatatom 449 503 5 0 0 0 - - -;
#X obj 619 435 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 729 435 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 939 435 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X floatatom 939 503 5 0 0 0 - - -;
#X obj 619 455 ofelia f \; y=0;
#X obj 729 455 ofelia f \; y=y+1;
#X obj 829 455 ofelia f \; y=2*y;
#X obj 939 455 ofelia f \; return y;
#X text 112 431 1;
#X text 922 431 6;
#X text 712 431 5;
#X text 602 431 4;
#X text 432 431 3;
#X text 222 431 2;
#X text 37 218 Os objetos [trigger] \, [delay] e [metro] introduzem
um controle temporal mais fino sobre o sequenciamento de ações no
patch. Eles são usados aqui para garantir que os vetores \, contendo
trechos do sinal utilizados para calcular as amplitudes \, sejam preenchidos
ANTES que a função em Lua seja executada. Para isso \, no momento
em que um cálculo é solicitado \, o trigger envia PRIMEIRO um bang
para o [tabwrite~] \, DEPOIS um bang para um objeto [delay] \, que
vai aguardar o tempo necessário para o preenchimento do vetor antes
de disparar a execução da função em Lua. A ordem de geração das
saídas do trigger é sempre DA DIREITA PARA A ESQUERDA \, o que é
compatível com a noção de inlets QUENTES e FRIOS que discutiremos
em outro momento., f 119;
#X text 37 362 Pode parecer estranho usar um [trigger] no lugar de
duas conexões saindo de um mesmo outlet: o problema com essa última
construção \, QUE NUNCA DEVERIA SER UTILIZADA \, é que fica visualmente
impossível determinar a ordem de execução nesses casos. Clique nos
bangs a seguir \, em ordem crescente \, e observe:, f 119;
#X text 37 538 NÃO SE ENGANE: isso ilustra um ERRO DE PROGRAMAÇÃO
e não uma falha na especificação da linguagem. Pd é um ambiente
de PROCESSAMENTO EM TEMPO REAL \, o que inclui o fato de que diversas
partes do patch incluem PROCESSAMENTOS SIMULTÂNEOS. Por isso \, NÃO
EXISTE qualquer PRECEDÊNCIA TEMPORAL em relação à POSIÇÃO GRÁFICA
dos objetos \, mas apenas em relação a suas POSIÇÕES LÓGICAS (ordem
relativa de suas conexões). No caso de conexões feitas a partir de
um mesmo outlet \, por definição elas são executadas NA ORDEM EM
QUE FORAM CRIADAS \, o que não é um atributo visível do patch. Por
isso \, como boa prática de programação \, sempre que você precisar
enviar uma mesma mensagem para dois pontos diferentes do patch \, sempre
use um [trigger] para explicitar o sequenciamento desejado (mesmo que
isso não tenha impacto no resultado final)., f 119;
#X connect 0 0 1 0;
#X connect 5 0 6 0;
#X connect 7 0 8 0;
#X connect 7 0 9 0;
#X connect 10 0 11 0;
#X connect 11 0 12 0;
#X connect 13 0 17 0;
#X connect 14 0 19 0;
#X connect 14 0 18 0;
#X connect 15 0 20 0;
#X connect 20 0 16 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 105 444 pd icsm115B+;
#X text 655 564 -65;
#X text 100 110 A implementação abaixo lhe permitirá explorar perceptualmente
as diversas medidas de amplitude \, definidas anteriormente \, nos
sinais elementares. Use os controles deslizantes de volume e preste
atenção na sua percepção de volume/intensidade/força sonora. Qual
controle lhe soa mais "natural"?, f 107;
#X floatatom 359 481 8 0 0 1 média #0_115B_bloco_ampmed -;
#X obj 362 507 hsl 128 20 0 1 0 0 empty empty empty -2 -8 0 16 -262144
-1 -1 0 1;
#X text 345 506 0;
#X text 493 506 1;
#X obj 195 206 tgl 24 0 \$0_115B_mute \$0_115B_mute_r MUTE 28 12 0
18 -262130 -1 -1 0 1;
#X obj 105 276 vradio 24 1 1 5 \$0_115B_mux \$0_115B_mux_r empty 0
-8 0 10 -262130 -1 -1 0;
#X text 137 301 RUÍDO;
#X text 137 276 SILÊNCIO;
#X text 137 324 SENOIDE;
#X text 137 349 DENTE-DE-SERRA;
#X text 137 372 QUADRADA;
#X text 356 367 AMPLITUDES (medidas), f 10;
#X text 686 427 ENERGIA (medida), f 9;
#X floatatom 539 421 5 0 0 1 pico #0_115B_sinal_aux_pico -;
#X floatatom 539 539 5 0 0 1 RMS #0_115B_sinal_aux_amprms -;
#X floatatom 539 481 5 0 0 1 média #0_115B_sinal_aux_ampmed -;
#X text 536 367 AMPLITUDES (teóricas), f 10;
#X floatatom 869 481 7 0 0 1 média #0_115B_sinal_aux_energia -;
#X floatatom 869 539 5 0 0 1 dB #0_115B_sinal_aux_energiadb -;
#X text 866 427 ENERGIA (teórica), f 9;
#N canvas 0 0 523 551 \$0_115B_síntese 0;
#X obj 45 175 r \$0_115B_mux;
#X obj 46 473 outlet~;
#X obj 255 389 zexy;
#X obj 95 209 noise~;
#X obj 144 239 osc~ 400;
#X obj 193 269 phasor~ 400;
#X obj 243 358 sgn~;
#X obj 45 389 multiplex~ 0 1 2 3 4;
#X obj 45 444 *~ 0;
#X text 42 24 Esse subpatch realiza a síntese de várias formas de
onda como visto na seção SINAIS ELEMENTARES. Note o uso do objeto
[outlet~] \, versão DSP do [outlet] \, e os [receives] para a seleção
"wireless" do tipo de forma de onda e controle de volume., f 42;
#X obj 193 298 *~ 2;
#X obj 193 328 -~ 1;
#X obj 82 416 r \$0_115B_vol;
#X connect 0 0 7 0;
#X connect 3 0 7 1;
#X connect 4 0 7 2;
#X connect 5 0 10 0;
#X connect 6 0 7 4;
#X connect 7 0 8 0;
#X connect 8 0 1 0;
#X connect 10 0 11 0;
#X connect 11 0 6 0;
#X connect 11 0 7 3;
#X connect 12 0 8 1;
#X restore 105 501 pd \$0_115B_síntese;
#N canvas 0 0 1280 700 \$0_115B_análise 0;
#X obj 58 91 inlet~;
#X obj 718 214 r \$0_115B_mux;
#X text 770 293 Escreve o sinal no vetor auxiliar;
#X text 54 32 Recebe o sinal sintetizado e computa as medidas de amplitude
usando Lua. As medidas de amplitude e energia são computadas tanto
no bloco DSP quanto também em um trecho maior (1 s) \, armazenado
no vetor \$0_115B_sinal., f 110;
#X obj 329 668 ofelia f;
#X msg 329 637 read -c icsm115B_analise.lua;
#X obj 112 238 loadbang;
#X obj 279 393 tabwrite~ \$0_115B_bloco;
#X obj 279 422 array define \$0_115B_bloco 64;
#X text 723 387 aguarda um pouco mais de 1 seg pelo preenchimento do
vetor auxiliar, f 36;
#X text 135 91 sinal da entrada;
#X obj 329 605 loadbang;
#X obj 112 267 metro 0.1 1 sec;
#X text 108 131 Ao invés de calcular a amplitude a cada 64 amostras
\, o que seria impossível de visualizar \, colocamos um "metrônomo"
para disparar o cálculo a cada 0.1 segundos \, a fim de aliviar a
carga computacional., f 43;
#X obj 112 296 trigger bang bang;
#X text 297 296 duplica cada bang do metrônomo \, enviando um para
o [tabwrite~] e outro para o [del], f 32;
#X text 278 362 guarda 64 amostras do sinal de entrada;
#X text 117 446 aguarda um pouco mais de 64 amostras para terminar
o preenchimento do vetor auxiliar, f 42;
#X obj 112 493 del 65 1 samp;
#X text 421 573 o cálculo das amplitudes e energias está no arquivo
icsm115B_analise.lua:, f 26;
#X text 119 528 dispara o cálculo das amplitudes e energias no bloco
, f 32;
#X text 727 467 dispara o cálculo das amplitudes e energias no vetor
"sinal", f 32;
#X obj 718 255 t b b;
#X text 783 255 o mesmo que [trigger bang bang];
#X text 715 84 Para obter estimativas mais estáveis e mais próximas
dos valores teóricos \, fazemos os mesmos cálculos em um vetor contendo
1 segundo do sinal \, a cada vez que o seletor de forma de onda é
acionado:, f 38;
#X obj 765 321 tabwrite~ \$0_115B_sinal_aux;
#X msg 718 511 symbol sinal_aux;
#X msg 112 573 symbol bloco;
#X obj 765 356 array define \$0_115B_sinal_aux 44100;
#X obj 718 434 del 1.01 1 sec;
#X text 715 559 OBS: o código em Lua nesse vetor de 1 segundo pode
causar interrupções no fluxo de áudio \, e por isso uma implementação
mais eficiente em Pd puro está incluída aqui:, f 35;
#N canvas 0 0 915 736 implementação_com_arrays 0;
#X obj 111 230 abs~;
#X obj 150 159 *~;
#X obj 81 490 / 44100;
#X obj 48 590 / 44100;
#X obj 81 691 expr 10*log10($f1);
#X obj 48 758 expr sqrt($f1);
#X obj 81 519 s \$0_115B_sinal_aux_ampmed;
#X obj 81 720 s \$0_115B_sinal_aux_energiadb;
#X obj 48 788 s \$0_115B_sinal_aux_amprms;
#X obj 115 651 s \$0_115B_sinal_aux_energia;
#X obj 115 422 s \$0_115B_sinal_aux_pico;
#X obj 467 267 array define \$0_115B_sinal_aux_abs 44100;
#X obj 467 194 array define \$0_115B_sinal_aux_sq 44100;
#X obj 111 267 tabwrite~ \$0_115B_sinal_aux_abs;
#X obj 149 194 tabwrite~ \$0_115B_sinal_aux_sq;
#X obj 115 386 array max \$0_115B_sinal_aux_abs;
#X obj 48 559 array sum \$0_115B_sinal_aux_sq;
#X obj 81 461 array sum \$0_115B_sinal_aux_abs;
#X obj 48 324 del 1.01 1 sec;
#X obj 151 123 inlet~;
#X obj 48 105 t b b b;
#X obj 48 353 t b b b;
#X obj 48 30 loadbang;
#X text 230 125 sinal de entrada;
#X text 193 157 sinal ao quadrado (energia);
#X text 161 229 valor absoluto do sinal;
#X text 439 388 calcula máximo;
#X text 404 462 calcula média;
#X obj 48 619 t f f f;
#X text 364 562 calcula soma dos quadrados (energia);
#X text 274 691 converte em dB;
#X text 200 759 converte em RMS;
#X obj 227 61 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 48 64 metro 1.1 1 sec;
#X text 206 30 Recalcula medidas de amplitude a cada 1.1 segundo;
#X text 203 324 aguarda tempo >1seg pra encher o vetor;
#X connect 0 0 13 0;
#X connect 1 0 14 0;
#X connect 2 0 6 0;
#X connect 3 0 28 0;
#X connect 4 0 7 0;
#X connect 5 0 8 0;
#X connect 15 0 10 0;
#X connect 16 0 3 0;
#X connect 17 0 2 0;
#X connect 18 0 21 0;
#X connect 19 0 0 0;
#X connect 19 0 1 0;
#X connect 19 0 1 1;
#X connect 20 0 18 0;
#X connect 20 1 13 0;
#X connect 20 2 14 0;
#X connect 21 0 16 0;
#X connect 21 1 17 0;
#X connect 21 2 15 0;
#X connect 22 0 33 0;
#X connect 28 0 5 0;
#X connect 28 1 4 0;
#X connect 28 2 9 0;
#X connect 32 0 33 0;
#X connect 33 0 20 0;
#X restore 717 665 pd implementação_com_arrays;
#X text 896 511 essa mensagem seria conectada ao [ofelia f], f 23
;
#X connect 0 0 7 0;
#X connect 0 0 25 0;
#X connect 0 0 31 0;
#X connect 1 0 22 0;
#X connect 5 0 4 0;
#X connect 6 0 12 0;
#X connect 11 0 5 0;
#X connect 12 0 14 0;
#X connect 14 0 18 0;
#X connect 14 1 7 0;
#X connect 18 0 27 0;
#X connect 22 0 29 0;
#X connect 22 1 25 0;
#X connect 27 0 4 0;
#X connect 29 0 26 0;
#X restore 128 546 pd \$0_115B_análise;
#N canvas 0 0 994 612 \$0_115B_dac 0;
#X obj 55 255 dac~;
#X obj 55 215 *~ 1;
#X text 399 105 controle liga/desliga;
#X text 90 90 controle mute;
#X obj 55 54 inlet~;
#X text 129 54 recebe sinal sintetizado;
#X obj 92 152 * -1;
#X obj 92 181 + 1;
#X text 145 150 (inverte valor do mute);
#X obj 143 197 loadbang;
#X obj 143 255 tabwrite~ \$0_115B_sinal;
#X obj 143 226 metro 100 64 samp;
#X obj 399 167 sel 0;
#X msg 566 216 \; pd dsp 1;
#X obj 399 296 f \$0;
#X obj 399 138 r \$0_115_dsp;
#X text 462 167 separa os casos 0/1:;
#X text 564 191 se 1 \, liga dsp;
#X text 407 263 se 0 \, reseta os controles e desliga dsp;
#X text 590 337 Existe um detalhe importante aqui: nos objetos os parâmetros
\$0 \, \$1 \, \$2 representam os argumentos de criação do objeto
(onde \$0 é o identificador do próprio objeto). Porém em mensagens
os parâmetros \$1 \, \$2 \, \$3 representam OS PARÂMETROS DE ENTRADA
DA MENSAGEM. Assim \, para endereçar os identificadores externos da
forma \$0_XYZ é necessário enviar o valor \$0 como primeiro parâmetro
($f1) da mensagem., f 36;
#X text 450 296 essa caixa de número recupera o valor mágico \$0
;
#X obj 92 123 r \$0_115B_mute;
#X msg 399 330 \; \$1_115B_vol_r 0 \; \$1_115B_mux_r 0 \; pd dsp 0
;
#X connect 1 0 0 0;
#X connect 1 0 0 1;
#X connect 4 0 1 0;
#X connect 4 0 10 0;
#X connect 6 0 7 0;
#X connect 7 0 1 1;
#X connect 9 0 11 0;
#X connect 11 0 10 0;
#X connect 12 0 14 0;
#X connect 12 1 13 0;
#X connect 14 0 22 0;
#X connect 15 0 12 0;
#X connect 21 0 6 0;
#X restore 104 588 pd \$0_115B_dac;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_115B_sinal 882 float 0;
#X coords 0 1.1 881 -1.1 300 180 1 0 0;
#X restore 876 220 graph;
#X connect 1 0 2 0;
#X connect 4 0 14 0;
#X connect 5 0 15 0;
#X connect 6 0 7 0;
#X connect 8 0 9 0;
#X connect 10 0 11 0;
#X connect 12 0 13 0;
#X connect 32 0 33 0;
#X connect 52 0 53 0;
#X connect 52 0 54 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm115B;
#X obj 100 70 cnv 15 14 14 empty empty Definições_de_Amplitude 0
0 0 28 -262144 -38 0;
#X text 100 120 Existem muitas maneiras de definir a amplitude de sinais:
, f 107;
#X text 100 148 A AMPLITUDE DE PICO é definida como o maior valor
absoluto dentre as amostras do sinal \, ou seja \, Amplitude(pico)=max(|x[0]|
\, |x[1]| \, ... \, |x[N-1]|). Essa medida pode não ser adequada para
representar um sinal predominantemente fraco que eventualmente alcança
um pico isolado \, um fenômeno que frequentemente não impacta nossa
percepção de volume sonoro. Por essa razão \, pode-se preferir a
medida da AMPLITUDE MÉDIA \, ou seja \, (|x[0]| \, |x[1]| \, ... \,
|x[N-1]|)/N., f 107;
#X text 100 254 Frequentemente se usa a noção de ENERGIA do sinal
\, que corresponde à soma dos quadrados das amplitudes instantâneas.
A ENERGIA MÉDIA em um segmento (x[0] \, x[1] \, ...x[N-1]) corresponde
portanto à expressão Energia = (x[0]²+x[1]²+...x[N-1]²)/N., f
107;
#X text 100 321 Uma forma de trazer os valores de energia de volta
à escala das amplitudes é tomar a raiz quadrada da energia média
\, o que coincide com a métrica conhecida como NORMA EUCLIDEANA em
geometria e corresponde à definição de AMPLITUDE RMS (Root-Mean-Square)
\, cujo acrônimo é uma abreviação de sua própria fórmula: RMS=sqrt((x[0]²+x[1]²+...x[N-1]²)/N).
, f 107;
#X text 100 406 Nenhuma dessas medidas se alinha muito bem com a maneira
como sons fortes e fracos são percebidos por nossos ouvidos \, que
se revelam muito mais sensíveis às variações de ORDENS DE GRANDEZA
da energia sonora: uma forma portanto de aproximar as medidas de amplitude
da nossa percepção é tomar o LOGARITMO da energia. A medida de 1
BEL é definida como uma VARIAÇÃO RELATIVA de 1 unidade na expressão
log_10(Energia) \, e a medida de energia em DECIBEIS é dada por Energia(dB)
= 10*log_10(Energia/E°) \, onde E° é um patamar referencial de energia.
Tomando E°=1 (sinal de amplitude máxima) teremos Energia(dB) = 10*log(Energia)
= 10*log(RMS²) = 2*10*log(RMS) \, e os valores em dB serão em geral
negativos. É possível também considerar E°=limiar inferior da audição
humana \, e nesse caso todos os sinais audíveis terão medidas de
Energia(dB) = 10*log_10(Energia/E°) positivas (essa é a escala dB
SPL = Sound Pressure Level)., f 107;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm115A;
#X text 100 330 A AMPLITUDE do sinal se refere à variação vertical
das amplitudes instantâneas \, ou seja \, dos valores das amostras
individuais \, e permite caracterizar sinais de acordo com sua "força"
ou "volume" sonoro., f 107;
#X text 100 270 Estes dois são possivelmente os parâmetros mais importantes
para caracterizar sinais sonoros:, f 107;
#X text 100 410 A FREQUÊNCIA se refere à "taxa de repetição" ou
periodicidade do sinal \, e permite caracterizar sinais no âmbito
da ALTURA MUSICAL \, que por sua vez é um parâmetro perceptual associado
aos termos GRAVE e AGUDO., f 107;
#N canvas 0 0 1211 491 mágica 0;
#X obj 47 117 r \$0_115_dsp;
#X obj 47 417 s \$0_115_dsp_r;
#X obj 47 243 spigot;
#X obj 167 228 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X msg 114 303 0;
#X obj 167 170 loadbang;
#X msg 167 199 1;
#X obj 47 274 t f b;
#X obj 47 303 pipe 1;
#X obj 47 361 pipe 1;
#X text 41 30 Esse subpatch conecta todos os toggles de todos os patches
\, além de alguns sliders \, sem criar loops infinitos!, f 113;
#X obj 490 234 spigot;
#X obj 610 219 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X msg 557 294 0;
#X obj 610 161 loadbang;
#X msg 610 190 1;
#X obj 490 265 t f b;
#X obj 490 294 pipe 1;
#X obj 490 352 pipe 1;
#X obj 490 323 t b f;
#X obj 720 234 spigot;
#X obj 840 219 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X msg 787 294 0;
#X obj 840 161 loadbang;
#X msg 840 190 1;
#X obj 720 265 t f b;
#X obj 720 294 pipe 1;
#X obj 720 352 pipe 1;
#X obj 720 323 t b f;
#X obj 960 234 spigot;
#X obj 1080 219 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1
1 1;
#X msg 1027 294 0;
#X obj 1080 161 loadbang;
#X msg 1080 190 1;
#X obj 960 265 t f b;
#X obj 960 294 pipe 1;
#X obj 960 352 pipe 1;
#X obj 960 323 t b f;
#X obj 960 117 r \$0_115F_N;
#X obj 960 417 s \$0_115F_N_r;
#X obj 48 494 loadbang;
#X obj 48 553 ofGetDspState;
#X obj 48 582 s \$0_115_dsp;
#X obj 48 523 del 1;
#X text 142 492 pega o estado global do DSP ao carregar o patch;
#X obj 47 332 t b f;
#X obj 490 117 r \$0_115B_vol;
#X obj 490 417 s \$0_115B_vol_r;
#X obj 720 117 r \$0_115D_freq;
#X obj 720 417 s \$0_115D_freq_r;
#X connect 0 0 2 0;
#X connect 2 0 7 0;
#X connect 3 0 2 1;
#X connect 4 0 3 0;
#X connect 5 0 6 0;
#X connect 6 0 3 0;
#X connect 7 0 8 0;
#X connect 7 1 4 0;
#X connect 8 0 45 0;
#X connect 9 0 6 0;
#X connect 11 0 16 0;
#X connect 12 0 11 1;
#X connect 13 0 12 0;
#X connect 14 0 15 0;
#X connect 15 0 12 0;
#X connect 16 0 17 0;
#X connect 16 1 13 0;
#X connect 17 0 19 0;
#X connect 18 0 15 0;
#X connect 19 0 18 0;
#X connect 19 1 47 0;
#X connect 20 0 25 0;
#X connect 21 0 20 1;
#X connect 22 0 21 0;
#X connect 23 0 24 0;
#X connect 24 0 21 0;
#X connect 25 0 26 0;
#X connect 25 1 22 0;
#X connect 26 0 28 0;
#X connect 27 0 24 0;
#X connect 28 0 27 0;
#X connect 28 1 49 0;
#X connect 29 0 34 0;
#X connect 30 0 29 1;
#X connect 31 0 30 0;
#X connect 32 0 33 0;
#X connect 33 0 30 0;
#X connect 34 0 35 0;
#X connect 34 1 31 0;
#X connect 35 0 37 0;
#X connect 36 0 33 0;
#X connect 37 0 36 0;
#X connect 37 1 39 0;
#X connect 38 0 29 0;
#X connect 40 0 43 0;
#X connect 41 0 42 0;
#X connect 43 0 41 0;
#X connect 45 0 9 0;
#X connect 45 1 1 0;
#X connect 46 0 11 0;
#X connect 48 0 20 0;
#X restore 1159 766 pd mágica;
