#N canvas 0 0 1280 700 16;
#X obj 0 0 icsm_cabecalho;
#X obj 100 200 cnv 15 14 14 empty empty 1.3.2_Equação_Geral_do_Filtro
0 0 0 34 -262144 -38 0;
#N canvas 0 0 1280 700 icsm132A 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm132A vis 1;
#N canvas 0 0 1280 700 icsm132B 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm132B vis 1;
#N canvas 0 0 1280 700 icsm132C 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm132C vis 1;
#N canvas 0 0 1280 700 icsm132D 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm132D vis 1;
#N canvas 0 0 1280 700 icsm132E 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm132E vis 1;
#X obj 100 100 cnv 15 14 14 empty empty Implementação_no_domínio_do_tempo_usando_fexpr~
0 0 0 28 -262144 -38 0;
#X obj 1115 152 icsm_dsp;
#X obj 102 312 fexpr~ 0.1*($x1[0]+$x1[-1]+$x1[-2]+$x1[-3]+$x1[-4]+$x1[-5]+$x1[-6]+$x1[-7]+$x1[-8]+$x1[-9])
, f 44;
#X text 353 246 produz um impulso discreto;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_132E_resp_imp_iir1 64 float 0;
#X coords 0 1 63 -1 200 140 1 0 0;
#X restore 740 431 graph;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_132E_resp_freq_iir1 64 float 0;
#X coords 0 1 63 0 200 140 1 0 0;
#X restore 980 431 graph;
#X obj 103 230 bng 15 250 50 0 empty \$0_132D_atualiza empty 17 7 0
10 -262144 -262144 -1;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_132E_resp_imp_fir1 64 float 0;
#X coords 0 1 63 -1 200 140 1 0 0;
#X restore 740 249 graph;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_132E_resp_freq_fir1 64 float 0;
#X coords 0 1 63 0 200 140 1 0 0;
#X restore 980 249 graph;
#X text 115 286 Exemplo FIR: y[n] = (x[n]+x[n-1]+···+x[n-9])/10
;
#X text 155 406 Exemplo IIR: y[n] = (x[n]-y[n-1]+x[n-2]-y[n-3]···+x[n-8]-y[n-9])/10
;
#X obj 152 452 fexpr~ 0.1*($x1[0]-$y1[-1]+$x1[-2]-$y1[-3]+$x1[-4]-$y1[-5]+$x1[-6]-$y1[-7]+$x1[-8]-$y1[-9])
, f 44;
#X text 100 150 Esse patch ilustra o uso do objeto [fexpr~] para a
construção de um filtro FIR e um filtro IIR de exemplo. Os gráficos
mostram as respostas ao impulso e em frequência destes filtros.,
f 91;
#N canvas 0 0 533 300 init 0;
#X obj 36 108 loadbang;
#X obj 83 165 metro 100;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_132E_impulso 2 float 2;
#X coords 0 1 2 -1 200 140 1 0 0;
#X restore 277 97 graph;
#X obj 36 136 t b b;
#X obj 36 195 f \$0;
#X obj 83 195 bng 15 250 50 0 \$0_132D_atualiza empty empty 17 7 0
10 -262144 -262144 -1;
#X text 276 43 impulso discreto;
#X text 38 16 inicializa impulso discreto e gera 10 bangs/segundo (send/rec
atualiza), f 21;
#X msg 36 224 \; \$1_132E_impulso 0 1 0;
#X connect 0 0 3 0;
#X connect 1 0 5 0;
#X connect 3 0 4 0;
#X connect 3 1 1 0;
#X connect 4 0 8 0;
#X restore 1106 191 pd init;
#N canvas 0 0 874 300 \$0_132E_plota_respostas 0;
#X obj 64 157 fft~;
#X obj 64 186 cyclone/cartopol~;
#X obj 444 157 fft~;
#X obj 444 186 cyclone/cartopol~;
#X obj 83 107 bng 15 250 50 0 empty \$0_132D_atualiza empty 17 7 0
10 -262144 -262144 -1;
#X obj 73 217 bng 15 250 50 0 empty \$0_132D_atualiza empty 17 7 0
10 -262144 -262144 -1;
#X obj 463 107 bng 15 250 50 0 empty \$0_132D_atualiza empty 17 7 0
10 -262144 -262144 -1;
#X obj 453 217 bng 15 250 50 0 empty \$0_132D_atualiza empty 17 7 0
10 -262144 -262144 -1;
#X obj 65 70 inlet~;
#X obj 445 70 inlet~;
#X text 63 32 recebe impulso filtrado pelo FIR;
#X text 442 32 recebe impulso filtrado pelo IIR;
#X obj 455 125 tabwrite~ \$0_132E_resp_imp_iir1;
#X obj 445 235 tabwrite~ \$0_132E_resp_freq_iir1;
#X obj 65 235 tabwrite~ \$0_132E_resp_freq_fir1;
#X obj 75 125 tabwrite~ \$0_132E_resp_imp_fir1;
#X connect 0 0 1 0;
#X connect 0 1 1 1;
#X connect 1 0 14 0;
#X connect 2 0 3 0;
#X connect 2 1 3 1;
#X connect 3 0 13 0;
#X connect 4 0 15 0;
#X connect 5 0 14 0;
#X connect 6 0 12 0;
#X connect 7 0 13 0;
#X connect 8 0 0 0;
#X connect 8 0 15 0;
#X connect 9 0 2 0;
#X connect 9 0 12 0;
#X restore 103 551 pd \$0_132E_plota_respostas;
#X obj 102 247 tabplay~ \$0_132E_impulso;
#N canvas 0 0 1280 700 icsm132F 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm132F vis 1;
#X obj 100 100 cnv 15 14 14 empty empty Implementação_no_domínio_do_tempo_usando_ofelia
0 0 0 28 -262144 -38 0;
#X text 354 246 produz um impulso discreto;
#X obj 103 228 bng 15 250 50 0 empty \$0_132D_atualiza empty 17 7 0
10 -262144 -262144 -1;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_132F_resp_imp 64 float 0;
#X coords 0 1 63 -1 200 140 1 0 0;
#X restore 980 261 graph;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_132F_resp_freq 64 float 0;
#X coords 0 1 63 0 200 140 1 0 0;
#X restore 980 431 graph;
#X text 288 276 Exemplo FIR: y[n] = (x[n]+x[n-1]+···+x[n-9])/10
;
#X msg 291 407 a 0.1 0 0.1 0 0.1 0 0.1 0 0.1 \, b 0 -0.1 0 -0.1 0 -0.1
0 -0.1 0 -0.1, f 30;
#X msg 291 299 a 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 \, b 0, f
42;
#X text 288 362 Exemplo IIR: y[n] = (x[n]-y[n-1]+x[n-2]-y[n-3]···+x[n-8]-y[n-9])/10
;
#N canvas 0 0 1280 700 filtro_ofelia 0;
#X obj 105 79 inlet~;
#X text 106 44 sinal a ser filtrado;
#X obj 704 74 inlet;
#X text 705 40 mensagens de inicialização;
#X obj 104 635 outlet~;
#X obj 104 112 ofelia d -s11 filtro_ofelia \; --[[ a e b são os coeficientes
do filtro \; x_ é o buffer circular de memória da entrada \; y_ é
o buffer circular de memória da saída \; px \, py são os índices
nos buffers circulares ]] \; M.a \, M.b \, M.x_ \, M.px \, M.y_ \,
M.py = ofTable(1) \, ofTable(0) \, ofTable(0) \, 1 \, ofTable(0) \,
1 \; --[[ função auxiliar: corrige o mod para 1..N ]] \; local function
mod(p \, N) return 1+(p-1)%N end \; --[[ calcula equação geral do
filtro recursivo ]] \; function ofelia.perform(x) \; for n=1 \, #x
do \; M.x_[M.px] = x[n] M.px = mod(M.px+1 \, #M.x_) \; x[n] = 0 \;
for m=1 \, #M.a do \; x[n] = x[n]+M.a[m]*M.x_[mod(M.px-m \, #M.x_)]
\; end \; for l=1 \, #M.b do \; x[n] = x[n]+M.b[l]*M.y_[mod(M.py-l-1
\, #M.y_)] \; end \; M.y_[M.py] = x[n] M.py = mod(M.py+1 \, #M.y_)
\; end \; return x \; end \;;
#X obj 704 112 ofelia d \; --[[ acessa variáveis do módulo ao lado]]
\; local m=require("filtro_ofelia") \; --[[ processa mensagens de inicialização
]] \; --[[ coeficientes do sinal de entrada ]] \; function ofelia.a(l)
\; m.a \, m.x_ \, m.px = ofTable() \, ofTable() \, 5 \; if type(l)=="number"
then l = ofTable(l) end \; for n=1 \, #l do \; m.a[n] \, m.x_[n] =
l[n] \, 0 \; end \; end \; --[[ coeficientes de retroalimentação
]] \; function ofelia.b(l) \; m.b \, m.y_ \, m.py = ofTable() \, ofTable()
\, 5 \; if type(l)=="number" then l = ofTable(l) end \; for n=1 \,
#l do \; m.b[n] \, m.y_[n] = l[n] \, 0 \; end \; end \;;
#X connect 0 0 5 0;
#X connect 2 0 6 0;
#X connect 5 0 4 0;
#X restore 103 512 pd filtro_ofelia;
#X text 121 484 calcula a equação geral do filtro recursivo;
#X obj 1115 152 icsm_dsp;
#N canvas 0 0 533 300 init 0;
#X obj 36 108 loadbang;
#X obj 83 165 metro 100;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_132F_impulso 2 float 2;
#X coords 0 1 2 -1 200 140 1 0 0;
#X restore 277 97 graph;
#X obj 36 136 t b b;
#X obj 36 195 f \$0;
#X obj 83 195 bng 15 250 50 0 \$0_132D_atualiza empty empty 17 7 0
10 -262144 -262144 -1;
#X text 276 43 impulso discreto;
#X text 38 16 inicializa impulso discreto e gera 10 bangs/segundo (send/rec
atualiza), f 21;
#X msg 36 224 \; \$1_132F_impulso 0 1 0;
#X connect 0 0 3 0;
#X connect 1 0 5 0;
#X connect 3 0 4 0;
#X connect 3 1 1 0;
#X connect 4 0 8 0;
#X restore 1106 191 pd init;
#X obj 103 247 tabplay~ \$0_132F_impulso;
#N canvas 0 0 450 300 \$0_132F_plota 0;
#X obj 73 147 fft~;
#X obj 73 176 cyclone/cartopol~;
#X obj 94 84 bng 15 250 50 0 empty \$0_132D_atualiza empty 17 7 0 10
-262144 -262144 -1;
#X obj 82 207 bng 15 250 50 0 empty \$0_132D_atualiza empty 17 7 0
10 -262144 -262144 -1;
#X obj 84 105 tabwrite~ \$0_132F_resp_imp;
#X obj 74 225 tabwrite~ \$0_132F_resp_freq;
#X obj 74 31 inlet~;
#X connect 0 0 1 0;
#X connect 0 1 1 1;
#X connect 1 0 5 0;
#X connect 2 0 4 0;
#X connect 3 0 5 0;
#X connect 6 0 4 0;
#X connect 6 0 0 0;
#X restore 103 541 pd \$0_132F_plota;
#X text 100 150 Esse patch ilustra o uso do objeto [ofelia] para a
construção de filtros FIR e IIR genéricos a partir de listas de
coeficientes. Os gráficos mostram as respostas ao impulso e em frequência
dos filtros de exemplo., f 94;
#N canvas 0 0 1280 700 icsm132G 0;
#X text 6 801 continua:;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm132G vis 1;
#X obj 100 100 cnv 15 14 14 empty empty Filtragem_no_domínio_da_frequência
0 0 0 28 -262144 -38 0;
#X text 510 224 ConvoluçãoRápida (x \, y);
#X text 550 244 X = FFT(x);
#X text 550 264 H = FFT(h);
#X text 550 284 Y = X·Η;
#X text 550 304 y = IFFT(Y);
#X text 100 150 O processo de filtragem no domínio da frequência
se apoia no TEOREMA DA CONVOLUÇÃO \, que estabelece que o resultado
da filtragem y = x*h é equivalente à transformação espectral Y
= X·H. Isso sugere o seguinte algoritmo \, que recebe o nome de convolução
rápida por se apoiar na implementação rápida da DFT:, f 107;
#X text 100 340 O terceiro passo do algoritmo acima pressupõe que
os espectros X e H têm o mesmo tamanho \, o que equivale a dizer que
os sinais originais x e h têm o mesmo tamanho. Essa condição geralmente
não vale \, mas pode ser forçada através da superamostragem do menor
dentre os espectros (geralmente H) \, o que equivale ao PREENCHIMENTO
POR ZEROS do vetor de coeficientes h. Em outras palavras \, o passo
2 do algoritmo acima fica, f 107;
#X text 550 424 H = FFT([h zeros(|x|-|h|)]);
#X text 100 470 A implementação desse processo em UM BLOCO DSP pode
ser feita trivialmente em Pd com os objetos [fft~] \, [ifft~] \, [tabplay~
h] para gerar o vetor h com preenchimento por zeros e cuidando-se de
implementar a multiplicação complexa corretamente ((a+ib)·(c+id)=(ac-bd)+i(ad+bc)).
De fato essa implementação já foi usada para o exemplo "Interpretação
Geométrica da Convolução" (subpatch icsm123E)., f 107;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm132G;
#X connect 1 0 2 0;
#X connect 5 0 16 0;
#X connect 9 0 12 1;
#X connect 10 0 12 1;
#X connect 12 0 17 0;
#X connect 16 0 12 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm132F;
#X connect 1 0 2 0;
#X connect 5 0 17 0;
#X connect 9 0 18 0;
#X connect 14 0 17 1;
#X connect 18 0 5 0;
#X connect 18 0 14 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm132E;
#X obj 100 100 cnv 15 14 14 empty empty Filtragem_no_Domínio_do_Tempo
0 0 0 28 -262144 -38 0;
#X obj 307 264 cnv 15 10 10 empty empty Σ 0 0 2 48 -262144 -1 0;
#X text 240 244 y[n] =;
#X text 306 270 m=L;
#X text 342 244 h[m]·x[n-m];
#X obj 717 264 cnv 15 10 10 empty empty Σ 0 0 2 48 -262144 -1 0;
#X text 646 244 y[n] =;
#X text 716 270 m=0;
#X text 716 220 N-1;
#X obj 897 264 cnv 15 10 10 empty empty Σ 0 0 2 48 -262144 -1 0;
#X text 752 244 a[m]·x[n-m] +;
#X text 896 270 l=1;
#X text 306 220 N-1;
#X text 242 194 FILTRO FIR (GENÉRICO);
#X text 692 194 FILTRO IIR (CASO RECURSIVO);
#X text 100 150 A filtragem no domínio do tempo consiste no cômputo
do sinal y[n] diretamente a partir de uma das equações, f 107;
#X text 532 244 ou;
#X text 932 244 b[l]·x[n-l].;
#X text 100 330 No caso dos filtros FIR não-causais (L<0) o cômputo
de y[n] depende do conhecimento da amostra futura x[n-L] \, o que no
caso de processamento em tempo real demanda uma latência de L amostras
na resposta., f 107;
#X text 100 490 No caso dos filtros IIR deve-se ter o cuidado de estabelecer
a priori sua ESTABILIDADE \, ou alternativamente implementar algum
método de controle de danos (por exemplo reinicializando todas as
variáveis auxiliares quando a saída extrapolar algum limiar de amplitude
previamente estabelecido)., f 107;
#X text 100 400 No caso de implementações que computam y[n] NO LUGAR
do vetor x[n] \, essas equações dependem de N+M variáveis auxiliares
para os valores x[n] \, x[n-1] \, ... \, x[n-N+1] e y[n-1] \, y[n-2]
\, ... \, y[n-M] \, atualizadas de forma ROTATIVA ou implementadas
como um BUFFER CIRCULAR., f 107;
#X text 906 220 M;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm132D;
#X obj 100 100 cnv 15 14 14 empty empty Filtros_IIR_e_Recursão 0 0
0 28 -262144 -38 0;
#X obj 487 224 cnv 15 10 10 empty empty Σ 0 0 2 48 -262144 -1 0;
#X text 416 204 y[n] =;
#X text 486 230 m=0;
#X text 486 180 N-1;
#X obj 667 224 cnv 15 10 10 empty empty Σ 0 0 2 48 -262144 -1 0;
#X text 522 204 a[m]·x[n-m] +;
#X text 702 204 b[l]·x[n-l];
#X text 666 230 l=1;
#X text 100 150 Uma das formas frequentes de definição de filtros
IIR é o uso de TERMOS DE RECURSÃO ou de RETROALIMENTAÇÃO na equação
do filtro:, f 107;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_132C_resposta 100 float 0;
#X coords 0 1 99 -1 400 140 1 0 0;
#X restore 103 486 graph;
#N canvas 0 0 450 300 \$0_132C_exemplo 0;
#X obj 50 30 loadbang;
#X obj 50 79 ofelia f \; local x=ofArray("\$0_132C_resposta") \; x[0]
= 1 \; local yn_1 = 1 \; for n=1 \, x:getSize()-1 do \; x[n] = -0.95*yn_1
\; yn_1 = x[n] \; end \;;
#X connect 0 0 1 0;
#X restore 543 602 pd \$0_132C_exemplo;
#X text 540 463 Observe que a presença de termos de recursão não
implica neces- sariamente que a resposta do filtro terá duração
infinita. Em situações particulares pode ocorrer o cancelamento de
termos de feedback \, como na equação y[n] = x[n]-x[n-1]+y[n-1] \,
cuja resposta ao impulso h[n] é o próprio impulso δ[n] (verifique).
, f 63;
#X text 100 375 Filtros IIR podem exibir a característica de INSTABILIDADE
\, que ocorre quando a resposta ao impulso não tende a zero quando
a entrada se anula \, e que também se relaciona com a eventualidade
de OVERFLOW no cômputo do sinal de saída. Uma condição de ESTABILIDADE
corresponde à FINITUDE da expressão Σ|h[n]|., f 107;
#X text 676 180 M;
#X text 100 260 onde o último somatório inclui no cômputo de y[n]
os valores y[n-1] \, y[n-2] \, ... \, y[n-M] que já estão disponíveis
na avaliação sequencial do sinal de saída \, tornando o tempo de
cálculo de cada amostra y[n] linear no número de coeficientes (N+M).
É importante destacar que os coeficientes a[m] e b[l] dessa equação
não correspondem mais à resposta ao impulso h[n] \, que continua
sendo definida como a resposta à entrada x[n] = δ[n]. O gráfico
abaixo mostra a resposta ao impulso do filtro com equação y[n] =
x[n]-0.9·y[n-1]., f 107;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm132C;
#X obj 100 100 cnv 15 14 14 empty empty Filtros_FIR_e_Causalidade 0
0 0 28 -262144 -38 0;
#X obj 557 254 cnv 15 10 10 empty empty Σ 0 0 2 48 -262144 -1 0;
#X text 490 234 y[n] =;
#X text 100 150 Os termos FIR (Finite Impulse Response) e IIR (Infinite
Impulse Response) são frequentemente utilizados para discriminar entre
filtros que podem ser implementados de forma direta por uma equação
do tipo, f 107;
#X text 556 260 m=L;
#X text 592 234 h[m]·x[n-m];
#X text 100 300 de outros filtros em que a duração de h é infinita
\, e que demandariam algum outro mecanismo computacional para viabilizar
a produção da saída em tempo finito. Frequentemente consideramos
a forma particular da equação do filtro FIR acima como, f 107;
#X obj 557 394 cnv 15 10 10 empty empty Σ 0 0 2 48 -262144 -1 0;
#X text 490 374 y[n] =;
#X text 592 374 h[m]·x[n-m];
#X text 556 400 m=0;
#X text 556 350 N-1;
#X text 100 430 em que todos os termos não nulos de h[m] estão nos
índices m>=0 \, de onde a expressão de y[n] combina linearmente apenas
as amostras x[n] \, x[n-1] \, ... \, x[n-N+1] do PRESENTE e do PASSADO
do sinal \, o que caracteriza a propriedade de CAUSALIDADE do filtro.
Filtros não-causais \, ou seja \, que dependem do FUTURO do sinal
\, podem ser implementados facilmente quando o sinal é todo conhecido
(por exemplo quando está em um ARQUIVO) \, mas oferecem dificuldades
nas implementações em TEMPO REAL (onde introduzem LATÊNCIA na resposta).
, f 107;
#X text 556 210 N-1;
#X text 950 225 L...N-1 são os índices em que h[m] é não-nulo,
f 22;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm132B;
#X obj 100 100 cnv 15 14 14 empty empty Resposta_ao_Impulso_e_Resposta_em_Frequência
0 0 0 28 -262144 -38 0;
#X text 100 150 Uma das formas de caracterização de um filtro linear
se dá pela equação de convolução e pelos coeficientes do sinal
h \, também chamado de RESPOSTA DO FILTRO AO IMPULSO \, por ser exatamente
a saída correspondente à entrada δ[n] = 1 se n=0 e δ[n] = 0 caso
contrário (um sinal chamado de IMPULSO ou DELTA DE DIRAC DISCRETO):
, f 107;
#X obj 477 274 cnv 15 10 10 empty empty Σ 0 0 2 48 -262144 -1 0;
#X text 486 280 m;
#X text 410 254 y[n] =;
#X text 512 254 h[m]·δ[n-m] = h[n]·δ[n-n] = h[n].;
#X text 100 320 Observe que a verificação acima mostra simultaneamente
que o Impulso Discreto é o ELEMENTO NEUTRO da operação de convolução
\, ou seja \, satisfaz x*δ = x para qualquer sinal x., f 107;
#X text 100 410 A segunda forma de caracterização de um filtro linear
usa o teorema da convolução e a equivalência da equação y = h*x
no domínio do tempo em relação à equação Y = H·X no domínio
da frequência. O sinal H \, que é a transformada de Fourier da resposta
ao impulso h \, é denominado RESPOSTA DO FILTRO EM FREQUÊNCIA. Lembrando
da interpretação polar da multiplicação complexa \, que corresponde
ao produto das magnitudes e à soma das fases \, vemos que cada coeficiente
H[k] da resposta em frequência descreve a ação do filtro na componente
X[k]·exp_k[n] do sinal da entrada., f 107;
#X connect 1 0 2 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 1000 600 pd icsm132A;
#X obj 577 344 cnv 15 10 10 empty empty Σ 0 0 2 48 -262144 -1 0;
#X text 586 350 m;
#X text 100 250 A EQUAÇÃO GERAL de um FILTRO LINEAR vem diretamente
da equação de convolução \, através da interpretação de um dos
sinais (x) como sinal de entrada e do outro (h) como coeficientes do
filtro:, f 107;
#X text 510 324 x[n] =;
#X text 612 324 h[m]·x[n-m].;
#X text 100 390 Veremos como essa equação se relaciona com os conceitos
de RESPOSTA AO IMPULSO \, que por sua vez permite distinguir FILTROS
COM RESPOSTA AO IMPULSO FINITA (FIR) e INFINITA (IIR) \, e como estes
últimos podem ser eficientemente implementados na forma de FILTROS
RECURSIVOS., f 107;
#X text 100 500 Finalmente \, veremos como filtros podem ser implementados
nos DOMÍNIOS DO TEMPO E DA FREQUÊNCIA \, bem como a forma de implementação
de filtros através da CONVOLUÇÃO RÁPIDA., f 107;
