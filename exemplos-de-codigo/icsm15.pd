#N canvas 0 0 1280 700 16;
#X declare -lib zexy;
#X declare -lib zexy;
#X declare -lib zexy;
#N canvas 0 0 450 300 icsm15_ 0;
#X obj 0 100 loadbang;
#X msg 0 150 \; pd-icsm15.pd vis 1 \; pd-icsm15_ vis 0 \; pd-icsm15A
vis 0 \; pd-icsm15B vis 0 \; pd-icsm15C vis 0 \; pd-icsm15D vis 0 \;
pd-icsm15E vis 0 \; pd-icsm15F vis 0 \; pd-icsm15G vis 0 \; pd-icsm15H
vis 0 \; pd-icsm15I vis 0;
#N canvas 0 0 1280 700 icsm15A 0;
#X obj 1100 650 icsm_anterior icsm15A icsm15.pd;
#X obj 1150 650 icsm_sobe icsm15A icsm1.pd;
#X obj 1200 650 icsm_proximo icsm15A icsm15B;
#X obj 100 70 cnv 15 14 14 empty empty Definições_de_Amplitude 0
0 0 28 -262144 -38 0;
#X text 100 120 Existem muitas maneiras de definir a amplitude de sinais:
, f 107;
#X text 100 148 A AMPLITUDE DE PICO é definida como o maior valor
absoluto dentre as amostras do sinal \, ou seja \, Amplitude(pico)=max(|x[0]|
\, |x[1]| \, ... \, |x[N-1]|). Essa medida pode não ser adequada para
representar um sinal predominantemente fraco que eventualmente alcança
um pico isolado \, um fenômeno que frequentemente não impacta nossa
percepção de volume sonoro. Por essa razão \, pode-se preferir a
medida da AMPLITUDE MÉDIA \, ou seja \, (|x[0]| \, |x[1]| \, ... \,
|x[N-1]|)/N., f 107;
#X text 100 254 Frequentemente se usa a noção de ENERGIA do sinal
\, que corresponde à soma dos quadrados das amplitudes instantâneas.
A ENERGIA MÉDIA em um segmento (x[0] \, x[1] \, ...x[N-1]) corresponde
portanto à expressão Energia = (x[0]²+x[1]²+...x[N-1]²)/N., f
107;
#X text 100 321 Uma forma de trazer os valores de energia de volta
à escala das amplitudes é tomar a raiz quadrada da energia média
\, o que coincide com a métrica conhecida como NORMA EUCLIDEANA em
geometria e corresponde à definição de AMPLITUDE RMS (Root-Mean-Square)
\, cujo acrônimo é uma abreviação de sua própria fórmula: RMS=sqrt((x[0]²+x[1]²+...x[N-1]²)/N).
, f 107;
#X text 100 406 Nenhuma dessas medidas se alinha muito bem com a maneira
como sons fortes e fracos são percebidos por nossos ouvidos \, que
se revelam muito mais sensíveis às variações de ORDENS DE GRANDEZA
da energia sonora: uma forma portanto de aproximar as medidas de amplitude
da nossa percepção é tomar o LOGARITMO da energia. A medida de 1
BEL é definida como uma VARIAÇÃO RELATIVA de 1 unidade na expressão
log_10(Energia) \, e a medida de energia em DECIBEIS é dada por Energia(dB)
= 10*log_10(Energia/E°) \, onde E° é um patamar referencial de energia.
Tomando E°=1 (sinal de amplitude máxima) teremos Energia(dB) = 10*log(Energia)
= 10*log(RMS²) = 2*10*log(RMS) \, e os valores em dB serão em geral
negativos. É possível também considerar E°=limiar inferior da audição
humana \, e nesse caso todos os sinais audíveis terão medidas de
Energia(dB) = 10*log_10(Energia/E°) positivas (essa é a escala dB
SPL = Sound Pressure Level)., f 107;
#X coords 0 0 1 1 100 100 0;
#X restore 0 0 pd icsm15A;
#N canvas 0 0 1280 700 icsm15B 0;
#X obj 1100 650 icsm_anterior icsm15B icsm15A;
#X obj 1150 650 icsm_sobe icsm15B icsm1.pd;
#X obj 1200 650 icsm_proximo icsm15B icsm15C;
#X obj 366 220 hsl 128 20 0 1 0 0 empty \$0B_vol_r Volume_(linear)
-2 -8 0 16 -262144 -1 -1 0 0;
#X obj 696 220 hsl 128 20 0.001 1 1 0 empty \$0B_vol_r Volume_(log)
-2 -8 0 16 -262144 -1 -1 0 0;
#X floatatom 359 421 8 0 0 1 pico #0B_bloco_pico -;
#X obj 362 448 hsl 128 20 0 1 0 0 empty empty empty -2 -8 0 16 -262144
-1 -1 0 1;
#X floatatom 359 539 8 0 0 1 RMS #0B_bloco_amprms -;
#X obj 362 565 hsl 128 20 0 1 0 0 empty empty empty -2 -8 0 16 -262144
-1 -1 0 1;
#X floatatom 689 481 8 0 0 1 média #0B_bloco_energia -;
#X obj 692 507 hsl 128 20 0 1 0 0 empty empty empty -2 -8 0 16 -262144
-1 -1 0 1;
#X floatatom 689 539 8 0 0 1 dB #0B_bloco_energiadb -;
#X obj 692 565 hsl 128 20 -65 0 0 0 empty empty empty -2 -8 0 16 -262144
-1 -1 0 1;
#X floatatom 363 244 8 0 1 0 - - #0B_vol;
#X floatatom 693 244 8 0 1 0 - - #0B_vol;
#X text 349 219 0;
#X text 679 219 0;
#X text 345 447 0;
#X text 675 506 0;
#X text 345 564 0;
#X text 823 564 0;
#X text 497 219 1;
#X text 827 219 1;
#X text 493 447 1;
#X text 823 506 1;
#X text 493 564 1;
#X obj 100 70 cnv 15 14 14 empty empty Experimento_com_Amplitude 0
0 0 28 -262144 -38 0;
#N canvas 0 0 1280 700 icsm15B+ 0;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm15B+ vis 1;
#X text 6 801 comentários:;
#X text 37 76 Sends/Receives são utilizados para enviar mensagens
entre objetos sem a necessidade de criar conexões visíveis. um [send
IDENTIFICADOR] (ou de forma abreviada [s IDENTIFICADOR]) enviará qualquer
dado que chegue ao seu inlet para quaisquer receptores [receive IDENTIFICADOR]
ou [r IDENTIFICADOR]. Isso é importante em diversos contextos: para
permitir a troca de mensagens entre objetos que não estão no mesmo
patch ou subpatch \, para diminuir a poluição visual associada a
conexões entre objetos distantes e para deixar mais limpas as interfaces
gráficas \, como chaves [toggle] \, botões [bng] e controles deslizantes
[hslider]/[vslider] \, que podem receber ou enviar diretamente informações
de outros pontos do patch (os sends/receives associados às interfaces
gráficas são acessíveis no respectivo menu "Propriedades")., f
119;
#X text 37 11 Esta implementação reutiliza vários objetos já vistos
\, mas traz uma interface gráfica nova (controle deslizante horizontal
ou [hslider]) \, um exemplo de uso de códigos em Lua armazenados em
arquivos externos \, e dois mecanismos importantíssimos da linguagem
Pd: o uso de objetos [send]/[receive] e os objetos [trigger] \, [delay]
e [metro]., f 119;
#X obj 129 435 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 129 455 ofelia f \; x=0;
#X obj 239 435 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 239 455 ofelia f \; x=x+1;
#X obj 339 455 ofelia f \; x=2*x;
#X obj 449 435 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 449 455 ofelia f \; return x;
#X floatatom 449 503 5 0 0 0 - - -;
#X obj 619 435 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 729 435 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 939 435 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X floatatom 939 503 5 0 0 0 - - -;
#X obj 619 455 ofelia f \; y=0;
#X obj 729 455 ofelia f \; y=y+1;
#X obj 829 455 ofelia f \; y=2*y;
#X obj 939 455 ofelia f \; return y;
#X text 112 431 1;
#X text 922 431 6;
#X text 712 431 5;
#X text 602 431 4;
#X text 432 431 3;
#X text 222 431 2;
#X text 37 218 Os objetos [trigger] \, [delay] e [metro] introduzem
um controle temporal mais fino sobre o sequenciamento de ações no
patch. Eles são usados aqui para garantir que os vetores \, contendo
trechos do sinal utilizados para calcular as amplitudes \, sejam preenchidos
ANTES que a função em Lua seja executada. Para isso \, no momento
em que um cálculo é solicitado \, o trigger envia PRIMEIRO um bang
para o [tabwrite~] \, DEPOIS um bang para um objeto [delay] \, que
vai aguardar o tempo necessário para o preenchimento do vetor antes
de disparar a execução da função em Lua. A ordem de geração das
saídas do trigger é sempre DA DIREITA PARA A ESQUERDA \, o que é
compatível com a noção de inlets QUENTES e FRIOS que discutiremos
em outro momento., f 119;
#X text 37 362 Pode parecer estranho usar um [trigger] no lugar de
duas conexões saindo de um mesmo outlet: o problema com essa última
construção \, QUE NUNCA DEVERIA SER UTILIZADA \, é que fica visualmente
impossível determinar a ordem de execução nesses casos. Clique nos
bangs a seguir \, em ordem crescente \, e observe:, f 119;
#X text 37 538 NÃO SE ENGANE: isso ilustra um ERRO DE PROGRAMAÇÃO
e não uma falha na especificação da linguagem. Pd é um ambiente
de PROCESSAMENTO EM TEMPO REAL \, o que inclui o fato de que diversas
partes do patch incluem PROCESSAMENTOS SIMULTÂNEOS. Por isso \, NÃO
EXISTE qualquer PRECEDÊNCIA TEMPORAL em relação à POSIÇÃO GRÁFICA
dos objetos \, mas apenas em relação a suas POSIÇÕES LÓGICAS (ordem
relativa de suas conexões). No caso de conexões feitas a partir de
um mesmo outlet \, por definição elas são executadas NA ORDEM EM
QUE FORAM CRIADAS \, o que não é um atributo visível do patch. Por
isso \, como boa prática de programação \, sempre que você precisar
enviar uma mesma mensagem para dois pontos diferentes do patch \, sempre
use um [trigger] para explicitar o sequenciamento desejado (mesmo que
isso não tenha impacto no resultado final)., f 119;
#X connect 0 0 1 0;
#X connect 5 0 6 0;
#X connect 7 0 8 0;
#X connect 7 0 9 0;
#X connect 10 0 11 0;
#X connect 11 0 12 0;
#X connect 13 0 17 0;
#X connect 14 0 19 0;
#X connect 14 0 18 0;
#X connect 15 0 20 0;
#X connect 20 0 16 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 105 444 pd icsm15B+;
#X text 655 564 -65;
#X text 100 110 A implementação abaixo lhe permitirá explorar perceptualmente
as diversas medidas de amplitude \, definidas anteriormente \, nos
sinais elementares. Use os controles deslizantes de volume e preste
atenção na sua percepção de volume/intensidade/força sonora. Qual
controle lhe soa mais "natural"?, f 107;
#X floatatom 359 481 8 0 0 1 média #0B_bloco_ampmed -;
#X obj 362 507 hsl 128 20 0 1 0 0 empty empty empty -2 -8 0 16 -262144
-1 -1 0 1;
#X text 345 506 0;
#X text 493 506 1;
#X obj 195 206 tgl 24 0 \$0B_mute \$0B_mute_r MUTE 28 12 0 18 -262130
-1 -1 0 1;
#X obj 105 276 vradio 24 1 1 5 \$0B_mux \$0B_mux_r empty 0 -8 0 10
-262130 -1 -1 0;
#X text 137 301 RUÍDO;
#X text 137 276 SILÊNCIO;
#X text 137 324 SENOIDE;
#X text 137 349 DENTE-DE-SERRA;
#X text 137 372 QUADRADA;
#X text 356 367 AMPLITUDES (medidas), f 10;
#X text 686 427 ENERGIA (medida), f 9;
#X floatatom 539 421 5 0 0 1 pico #0B_sinal_aux_pico -;
#X floatatom 539 539 5 0 0 1 RMS #0B_sinal_aux_amprms -;
#X floatatom 539 481 5 0 0 1 média #0B_sinal_aux_ampmed -;
#X text 536 367 AMPLITUDES (teóricas), f 10;
#X floatatom 869 481 7 0 0 1 média #0B_sinal_aux_energia -;
#X floatatom 869 539 5 0 0 1 dB #0B_sinal_aux_energiadb -;
#X text 866 427 ENERGIA (teórica), f 9;
#N canvas 0 0 523 551 \$0B_síntese 0;
#X obj 45 175 r \$0B_mux;
#X obj 46 473 outlet~;
#X obj 95 209 noise~;
#X obj 144 239 osc~ 400;
#X obj 193 269 phasor~ 400;
#X obj 243 358 sgn~;
#X obj 45 389 multiplex~ 0 1 2 3 4;
#X obj 45 444 *~ 0;
#X text 42 24 Esse subpatch realiza a síntese de várias formas de
onda como visto na seção SINAIS ELEMENTARES. Note o uso do objeto
[outlet~] \, versão DSP do [outlet] \, e os [receives] para a seleção
"wireless" do tipo de forma de onda e controle de volume., f 42;
#X obj 193 298 *~ 2;
#X obj 193 328 -~ 1;
#X obj 82 416 r \$0B_vol;
#X obj 255 389 declare -lib zexy;
#X connect 0 0 6 0;
#X connect 2 0 6 1;
#X connect 3 0 6 2;
#X connect 4 0 9 0;
#X connect 5 0 6 4;
#X connect 6 0 7 0;
#X connect 7 0 1 0;
#X connect 9 0 10 0;
#X connect 10 0 5 0;
#X connect 10 0 6 3;
#X connect 11 0 7 1;
#X restore 105 501 pd \$0B_síntese;
#N canvas 0 0 1280 700 \$0B_análise 0;
#X obj 58 91 inlet~;
#X obj 718 214 r \$0B_mux;
#X text 770 293 Escreve o sinal no vetor auxiliar;
#X text 54 32 Recebe o sinal sintetizado e computa as medidas de amplitude
usando Lua. As medidas de amplitude e energia são computadas tanto
no bloco DSP quanto também em um trecho maior (1 s) \, armazenado
no vetor \$0B_sinal., f 110;
#X obj 329 668 ofelia f;
#X msg 329 637 read -c icsm15B_analise.lua;
#X obj 112 238 loadbang;
#X obj 279 393 tabwrite~ \$0B_bloco;
#X obj 279 422 array define \$0B_bloco 64;
#X text 723 387 aguarda um pouco mais de 1 seg pelo preenchimento do
vetor auxiliar, f 36;
#X text 135 91 sinal da entrada;
#X obj 329 605 loadbang;
#X obj 112 267 metro 0.1 1 sec;
#X text 108 131 Ao invés de calcular a amplitude a cada 64 amostras
\, o que seria impossível de visualizar \, colocamos um "metrônomo"
para disparar o cálculo a cada 0.1 segundos \, a fim de aliviar a
carga computacional., f 43;
#X obj 112 296 trigger bang bang;
#X text 297 296 duplica cada bang do metrônomo \, enviando um para
o [tabwrite~] e outro para o [del], f 32;
#X text 278 362 guarda 64 amostras do sinal de entrada;
#X text 117 446 aguarda um pouco mais de 64 amostras para terminar
o preenchimento do vetor auxiliar, f 42;
#X obj 112 493 del 65 1 samp;
#X text 421 573 o cálculo das amplitudes e energias está no arquivo
icsm15B_analise.lua:, f 26;
#X text 119 528 dispara o cálculo das amplitudes e energias no bloco
, f 32;
#X text 727 467 dispara o cálculo das amplitudes e energias no vetor
"sinal", f 32;
#X obj 718 255 t b b;
#X text 783 255 o mesmo que [trigger bang bang];
#X text 715 84 Para obter estimativas mais estáveis e mais próximas
dos valores teóricos \, fazemos os mesmos cálculos em um vetor contendo
1 segundo do sinal \, a cada vez que o seletor de forma de onda é
acionado:, f 38;
#X obj 765 321 tabwrite~ \$0B_sinal_aux;
#X msg 718 511 symbol sinal_aux;
#X msg 112 573 symbol bloco;
#X obj 765 356 array define \$0B_sinal_aux 44100;
#X obj 718 434 del 1.01 1 sec;
#X text 715 559 OBS: o código em Lua nesse vetor de 1 segundo pode
causar interrupções no fluxo de áudio \, e por isso uma implementação
mais eficiente em Pd puro está incluída aqui:, f 35;
#N canvas 0 0 915 709 implementação_com_arrays 0;
#X obj 111 230 abs~;
#X obj 150 159 *~;
#X obj 81 490 / 44100;
#X obj 48 590 / 44100;
#X obj 81 691 expr 10*log10($f1);
#X obj 48 758 expr sqrt($f1);
#X obj 81 519 s \$0B_sinal_aux_ampmed;
#X obj 81 720 s \$0B_sinal_aux_energiadb;
#X obj 48 788 s \$0B_sinal_aux_amprms;
#X obj 15 651 s \$0B_sinal_aux_energia;
#X obj 15 422 s \$0B_sinal_aux_pico;
#X obj 467 267 array define \$0B_sinal_aux_abs 44100;
#X obj 467 194 array define \$0B_sinal_aux_sq 44100;
#X obj 111 267 tabwrite~ \$0B_sinal_aux_abs;
#X obj 149 194 tabwrite~ \$0B_sinal_aux_sq;
#X obj 115 386 array max \$0B_sinal_aux_abs;
#X obj 48 559 array sum \$0B_sinal_aux_sq;
#X obj 81 461 array sum \$0B_sinal_aux_abs;
#X obj 48 324 del 1.01 1 sec;
#X obj 151 123 inlet~;
#X obj 48 105 t b b b;
#X obj 48 353 t b b b;
#X obj 48 30 loadbang;
#X text 230 125 sinal de entrada;
#X text 193 157 sinal ao quadrado (energia);
#X text 161 229 valor absoluto do sinal;
#X text 439 388 calcula máximo;
#X text 404 462 calcula média;
#X obj 48 619 t f f f;
#X text 364 562 calcula soma dos quadrados (energia);
#X text 274 691 converte em dB;
#X text 200 759 converte em RMS;
#X obj 227 61 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 48 64 metro 1.1 1 sec;
#X text 206 30 Recalcula medidas de amplitude a cada 1.1 segundo;
#X text 203 324 aguarda tempo >1seg pra encher o vetor;
#X connect 0 0 13 0;
#X connect 1 0 14 0;
#X connect 2 0 6 0;
#X connect 3 0 28 0;
#X connect 4 0 7 0;
#X connect 5 0 8 0;
#X connect 15 0 10 0;
#X connect 16 0 3 0;
#X connect 17 0 2 0;
#X connect 18 0 21 0;
#X connect 19 0 0 0;
#X connect 19 0 1 0;
#X connect 19 0 1 1;
#X connect 20 0 18 0;
#X connect 20 1 13 0;
#X connect 20 2 14 0;
#X connect 21 0 16 0;
#X connect 21 1 17 0;
#X connect 21 2 15 0;
#X connect 22 0 33 0;
#X connect 28 0 5 0;
#X connect 28 1 4 0;
#X connect 28 2 9 0;
#X connect 32 0 33 0;
#X connect 33 0 20 0;
#X restore 717 665 pd implementação_com_arrays;
#X text 896 511 essa mensagem seria conectada ao [ofelia f], f 23
;
#X connect 0 0 7 0;
#X connect 0 0 25 0;
#X connect 0 0 31 0;
#X connect 1 0 22 0;
#X connect 5 0 4 0;
#X connect 6 0 12 0;
#X connect 11 0 5 0;
#X connect 12 0 14 0;
#X connect 14 0 18 0;
#X connect 14 1 7 0;
#X connect 18 0 27 0;
#X connect 22 0 29 0;
#X connect 22 1 25 0;
#X connect 27 0 4 0;
#X connect 29 0 26 0;
#X restore 128 546 pd \$0B_análise;
#N canvas 0 0 447 345 \$0B_dac 0;
#X obj 55 255 dac~;
#X obj 55 215 *~ 1;
#X text 90 90 controle mute;
#X obj 55 54 inlet~;
#X text 129 54 recebe sinal sintetizado;
#X obj 92 152 * -1;
#X obj 92 181 + 1;
#X text 145 150 (inverte valor do mute);
#X obj 143 197 loadbang;
#X obj 143 255 tabwrite~ \$0B_sinal;
#X obj 143 226 metro 100 64 samp;
#X obj 92 123 r \$0B_mute;
#X connect 1 0 0 0;
#X connect 1 0 0 1;
#X connect 3 0 1 0;
#X connect 3 0 9 0;
#X connect 5 0 6 0;
#X connect 6 0 1 1;
#X connect 8 0 10 0;
#X connect 10 0 9 0;
#X connect 11 0 5 0;
#X restore 104 588 pd \$0B_dac;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0B_sinal 882 float 0;
#X coords 0 1.1 881 -1.1 300 180 1 0 0;
#X restore 876 220 graph;
#N canvas 0 0 754 595 mágica 0;
#X obj 44 240 spigot;
#X obj 164 225 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X msg 111 300 0;
#X obj 164 167 loadbang;
#X msg 164 196 1;
#X obj 44 271 t f b;
#X obj 44 300 pipe 1;
#X obj 44 358 pipe 1;
#X obj 44 329 t b f;
#X obj 44 123 r \$0B_vol;
#X obj 44 423 s \$0B_vol_r;
#X obj 319 176 f \$0;
#X text 316 313 Existe um detalhe importante aqui: nos objetos os parâmetros
\$0 \, \$1 \, \$2 representam os argumentos de criação do objeto
(onde \$0 é o identificador do próprio objeto). Porém em mensagens
os parâmetros \$1 \, \$2 \, \$3 representam OS PARÂMETROS DE ENTRADA
DA MENSAGEM. Assim \, para endereçar os identificadores externos da
forma \$0_XYZ é necessário enviar o valor \$0 como primeiro parâmetro
($f1) da mensagem., f 36;
#X text 370 176 essa caixa de número recupera o valor mágico \$0
, f 29;
#X obj 319 88 r pd;
#X obj 319 117 route dsp;
#X obj 319 146 sel 0;
#X text 41 30 Esse subpatch conecta alguns sliders do patch sem criar
loops infinitos, f 25;
#X text 316 30 e reseta alguns controles quando o DSP é desligado
, f 25;
#X msg 319 220 \; \$1B_vol_r 0 \; \$1B_mux_r 0 \; \$1B_sinal const
0;
#X connect 0 0 5 0;
#X connect 1 0 0 1;
#X connect 2 0 1 0;
#X connect 3 0 4 0;
#X connect 4 0 1 0;
#X connect 5 0 6 0;
#X connect 5 1 2 0;
#X connect 6 0 8 0;
#X connect 7 0 4 0;
#X connect 8 0 7 0;
#X connect 8 1 10 0;
#X connect 9 0 0 0;
#X connect 11 0 19 0;
#X connect 14 0 15 0;
#X connect 15 0 16 0;
#X connect 16 0 11 0;
#X coords 0 -1 1 1 2 2 2 0 0;
#X restore 1174 400 pd mágica;
#X obj 102 203 icsm_dsp;
#N canvas 0 0 817 574 icsm15B++ 0;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm15B++ vis 1;
#X text 6 801 +detalhes(*):;
#X text 55 43 Para as formas de onda elementares \, é possível calcular
todas as medidas de amplitude e energia de forma analítica \, considerando
a soma (integral) dos valores das funções |x(t)| ou |x(t)|^2 no intervalo
correspondente a um período completo. Assim temos:, f 67;
#X text 146 139 AMP(PICO);
#X text 256 139 AMP(MED);
#X text 366 139 AMP(RMS);
#X text 476 139 ENERGIA(MED);
#X text 616 139 ENERGIA(dB);
#X text 55 183 SENOIDE;
#X text 55 213 QUADRADA;
#X text 55 243 DENTE;
#X text 55 273 RUÍDO;
#X text 175 183 1;
#X text 245 183 2/π~0.637;
#X text 505 183 0.5;
#X text 175 213 1;
#X text 285 213 1;
#X text 405 213 1;
#X text 515 213 1;
#X text 655 213 0;
#X text 175 243 1;
#X text 275 243 0.5;
#X text 505 243 1/3;
#X text 625 243 ~-4.77;
#X text 625 183 ~-3.01;
#X text 175 273 1;
#X text 275 273 0.5;
#X text 505 273 1/3;
#X text 625 273 ~-4.77;
#X text 375 243 ~0.577;
#X text 375 273 ~0.577;
#X text 375 183 ~0.707;
#X text 55 323 No caso do ruído esse cálculo involve \, além de
integrais \, também os modelos de funções de densidade de probabilidade
e de densidade acumulada \, de tal forma que as médias dos valores
de |x(t)| ou |x(t)|^2 se convertem em esperanças. No caso do ruído
branco \, todas as medidas são equivalentes à da forma de dente-de-serra
\, cuja distribuição de valores de amplitude possui características
semelhantes às do ruído branco (igual "frequência" de cada valor
no intervalo [-1 \, +1]., f 67;
#X connect 0 0 1 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 670 371 pd icsm15B++;
#X connect 3 0 13 0;
#X connect 4 0 14 0;
#X connect 5 0 6 0;
#X connect 7 0 8 0;
#X connect 9 0 10 0;
#X connect 11 0 12 0;
#X connect 30 0 31 0;
#X connect 50 0 51 0;
#X connect 50 0 52 0;
#X coords 0 0 1 1 100 100 0;
#X restore 150 0 pd icsm15B;
#N canvas 0 0 1280 700 icsm15C 0;
#X obj 1100 650 icsm_anterior icsm15C icsm15B;
#X obj 1150 650 icsm_sobe icsm15C icsm1.pd;
#X obj 1200 650 icsm_proximo icsm15C icsm15D;
#X obj 100 90 cnv 15 14 14 empty empty Frequência_Instantânea_e_Estimação
0 0 0 28 -262144 -38 0;
#X text 100 150 Como vimos anteriormente \, a FREQUÊNCIA de um sinal
periódico (como uma SENOIDE) é definida como o inverso do PERÍODO
\, que por sua vez é o menor valor de τ>0 para o qual x(t+τ)=x(t)
para qualquer t. Para sinais "quase" periódicos é possível definir
uma FREQUÊNCIA APROXIMADA considerando a equação acima também de
forma aproximada (formalmente seria necessário considerar a minimização
do erro absoluto e(t)=|x(t+τ)=x(t)|). Para sinais que não sejam periódicos
ainda é possível definir uma FREQUÊNCIA INSTANTÂNEA considerando
a frequência aproximada obtida em uma JANELA TEMPORAL pequena (por
exemplo \, de alguns milissegundos). Estimar precisamente a frequência
instantânea não é uma tarefa trivial \, e será discutida em detalhes
no capítulo sobre ANÁLISE., f 107;
#X text 100 340 Um estimador BASTANTE IMPRECISO (mas simples) para
a frequência de um sinal senoidal pode ser obtido contabilizando-se
a quantidade de trocas de sinal (positivo->negativo e vice-versa) do
sinal sonoro por segundo. Como o sinal senoidal cruza o eixo horizontal
exatamente 2 vezes por período \, sua frequência pode ser estimada
como a metade da TAXA DE CRUZAMENTOS POR ZERO (ZCR = Zero-Crossing
Rate). Essa é uma medida cuja precisão depende do horizonte de tempo
considerado \, e será tanto mais imprecisa quanto menor a janela de
observação \, particularmente para frequências baixas (que possuem
períodos altos). Uma senoide de 20 Hz por exemplo terá um período
de 1/20 = 0.05 segundos ou 50 milissegundos \, o que corresponde a
mais de 34 blocos DSP do Pd com a configuração default. Em particular
\, qualquer frequência menor do que 44100/64 = 689 Hz não poderá
sequer completar 1 período dentro de 1 bloco DSP (isso explica por
exemplo que no experimento anterior as amplitudes dos sinais em blocos
de 64 amostras flutuassem tanto)., f 107;
#X coords 0 0 1 1 100 100 0;
#X restore 300 0 pd icsm15C;
#N canvas 0 0 1280 700 icsm15D 0;
#X obj 1100 650 icsm_anterior icsm15D icsm15C;
#X obj 1150 650 icsm_sobe icsm15D icsm1.pd;
#X obj 1200 650 icsm_proximo icsm15D icsm15E;
#X obj 321 220 hsl 128 20 0.001 1 1 0 empty \$0D_vol_r Volume -2 -8
0 16 -262144 -1 -1 0 0;
#X floatatom 408 394 8 0 0 1 ZCR #0D_zcr -;
#X obj 411 507 hsl 256 20 20 20000 0 0 empty empty Frequência_estimada_(linear)
-2 -8 0 16 -262144 -1 -1 0 1;
#X floatatom 318 244 8 0 1 0 - - #0D_vol;
#X text 304 219 0;
#X text 452 219 1;
#X obj 100 70 cnv 15 14 14 empty empty Experimento_com_Frequência
0 0 0 28 -262144 -38 0;
#X obj 521 220 hsl 256 20 20 20000 0 0 empty \$0D_freq_r Frequência_(linear)
-2 -8 0 16 -262144 -1 -1 0 0;
#X floatatom 518 244 8 20 20000 1 Hz - #0D_freq;
#X text 781 218 20k;
#X text 494 219 20;
#X obj 861 220 hsl 256 20 20 20000 1 0 empty \$0D_freq_r Frequência_(log)
-2 -8 0 16 -262144 -1 -1 0 0;
#X floatatom 858 244 8 20 20000 1 Hz - #0D_freq;
#X text 1121 218 20k;
#X text 834 219 20;
#X text 671 505 20k;
#X text 384 506 20;
#X floatatom 407 579 8 0 0 1 Hz - -;
#X obj 410 550 hsl 256 20 20 20000 1 0 empty empty Frequência_estimada_(log)
-2 -8 0 16 -262144 -1 -1 0 1;
#X text 670 548 20k;
#X text 383 549 20;
#X text 383 579 F0;
#X text 406 350 Observe aqui os valores de frequência instantânea
(F0) estimados pelo ZCR:, f 38;
#X obj 408 450 expr ($f1/2)*44100/64;
#X obj 195 206 tgl 24 0 \$0D_mute \$0D_mute_r MUTE 28 12 0 18 -262130
-1 -1 0 1;
#X text 100 110 Nesse experimento controlaremos a frequência de um
sinal elementar a fim de observarmos como nossa percepção se comporta
em relação à variação desse parâmetro. Use os dois controles
deslizantes \, com distribuições linear e logarítmica na frequência
\, e preste atenção à sua percepção de altura musical (grave/agudo).
Qual controle parece corresponder melhor à sua percepção?, f 107
;
#X obj 105 276 vradio 24 1 1 4 \$0D_mux \$0D_mux_r empty 0 -8 0 10
-262130 -1 -1 0;
#X text 137 276 SILÊNCIO;
#X text 137 302 SENOIDE;
#X text 137 327 DENTE-DE-SERRA;
#X text 137 350 QUADRADA;
#N canvas 0 0 523 551 \$0D_síntese 0;
#X obj 46 473 outlet~;
#X obj 223 358 sgn~;
#X obj 45 444 *~ 0;
#X obj 163 298 *~ 2;
#X obj 163 328 -~ 1;
#X obj 45 145 r \$0D_mux;
#X text 42 24 Esse subpatch \, quase idêntico ao do subpatch icsm15B
\, realiza a síntese de várias formas de onda periódicas \, como
visto na seção SINAIS ELEMENTARES., f 42;
#X obj 45 389 multiplex~ 0 1 2 3;
#X obj 82 416 r \$0D_vol;
#X obj 104 206 t f f;
#X obj 104 239 osc~;
#X obj 163 269 phasor~;
#X obj 104 177 r \$0D_freq;
#X obj 255 389 declare -lib zexy;
#X connect 1 0 7 3;
#X connect 2 0 0 0;
#X connect 3 0 4 0;
#X connect 4 0 1 0;
#X connect 4 0 7 2;
#X connect 5 0 7 0;
#X connect 7 0 2 0;
#X connect 8 0 2 1;
#X connect 9 0 10 0;
#X connect 9 1 11 0;
#X connect 10 0 7 1;
#X connect 11 0 3 0;
#X connect 12 0 9 0;
#X restore 105 471 pd \$0D_síntese;
#N canvas 0 0 439 339 \$0D_dac 0;
#X obj 55 255 dac~;
#X obj 55 215 *~ 1;
#X text 90 90 controle mute;
#X obj 55 54 inlet~;
#X text 129 54 recebe sinal sintetizado;
#X obj 92 152 * -1;
#X obj 92 181 + 1;
#X text 145 150 (inverte valor do mute);
#X obj 143 197 loadbang;
#X obj 143 255 tabwrite~ \$0D_sinal;
#X obj 143 226 metro 100 64 samp;
#X obj 92 123 r \$0D_mute;
#X connect 1 0 0 0;
#X connect 1 0 0 1;
#X connect 3 0 1 0;
#X connect 3 0 9 0;
#X connect 5 0 6 0;
#X connect 6 0 1 1;
#X connect 8 0 10 0;
#X connect 10 0 9 0;
#X connect 11 0 5 0;
#X restore 104 558 pd \$0D_dac;
#N canvas 0 0 521 342 \$0D_análise 0;
#X obj 47 99 inlet~;
#X text 44 10 Conta a quantidade de vezes que amostras sucessivas dentro
de um mesmo bloco trocam de sinal., f 39;
#X obj 48 132 ofelia f -s10 \; local sendzcr = ofSend("\$0D_zcr") \;
local zcr = 0 \; for i = 1 \, #a1-1 do \; if a1[i]*a1[i+1]<0 then \;
zcr = zcr+1 \; end \; end \; sendzcr:sendFloat(zcr) \;;
#X connect 0 0 2 0;
#X restore 152 513 pd \$0D_análise;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0D_sinal 882 float 0;
#X coords 0 1.1 881 -1.1 300 180 1 0 0;
#X restore 880 393 graph;
#N canvas 0 0 630 473 icsm15D+ 0;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm15D+ vis 1;
#X text 33 121 O experimento \, por outro lado \, envolve elementos
bastante complexos \, tanto perceptuais quanto matemáticos \, e que
merecem ser observados:, f 50;
#X text 93 201 (1) observe como sua percepção lida com o parâmetro
perceptual de AMPLITUDE enquanto você varia a frequência. Essa observação
tem relação com o experimento que relaciona amplitude e frequência
\, ainda nesta seção., f 44;
#X text 93 311 (2) observe o que acontece com os sinais dente-de-serra
e quadrado quando você vai para as frequências mais altas/agudas.
Esses (d)efeitos tem relação com o fenômeno do REBATIMENTO \, abordado
na próxima seção., f 44;
#X text 6 801 comentários:;
#X text 33 21 Essa implementação é substancialmente mais simples
do que a anterior \, sendo que o único objeto novo é o [expr] \,
uma calculadora poderosa com um patch de Ajuda bastante detalhado e
que merece ser lido., f 50;
#X connect 0 0 1 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 106 407 pd icsm15D+;
#X obj 102 203 icsm_dsp;
#N canvas 0 0 670 472 mágica 0;
#X obj 44 210 spigot;
#X obj 164 195 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X msg 111 270 0;
#X obj 164 137 loadbang;
#X msg 164 166 1;
#X obj 44 241 t f b;
#X obj 44 270 pipe 1;
#X obj 44 328 pipe 1;
#X obj 44 299 t b f;
#X obj 44 93 r \$0D_freq;
#X obj 44 393 s \$0D_freq_r;
#X obj 359 176 f \$0;
#X obj 359 88 r pd;
#X obj 359 117 route dsp;
#X obj 359 146 sel 0;
#X text 41 30 Esse subpatch conecta alguns sliders do patch sem criar
loops infinitos, f 29;
#X text 356 30 e reseta alguns controles quando o DSP é desligado
, f 25;
#X msg 359 220 \; \$1D_vol_r 0 \; \$1D_mux_r 0 \; \$1D_freq_r 0 \;
\$1D_sinal const 0;
#X connect 0 0 5 0;
#X connect 1 0 0 1;
#X connect 2 0 1 0;
#X connect 3 0 4 0;
#X connect 4 0 1 0;
#X connect 5 0 6 0;
#X connect 5 1 2 0;
#X connect 6 0 8 0;
#X connect 7 0 4 0;
#X connect 8 0 7 0;
#X connect 8 1 10 0;
#X connect 9 0 0 0;
#X connect 11 0 17 0;
#X connect 12 0 13 0;
#X connect 13 0 14 0;
#X connect 14 0 11 0;
#X coords 0 -1 1 1 2 2 2 0 0;
#X restore 1178 573 pd mágica;
#X connect 3 0 6 0;
#X connect 4 0 26 0;
#X connect 5 0 21 0;
#X connect 10 0 11 0;
#X connect 14 0 15 0;
#X connect 21 0 20 0;
#X connect 26 0 5 0;
#X connect 34 0 35 0;
#X connect 34 0 36 0;
#X coords 0 0 1 1 100 100 0;
#X restore 450 0 pd icsm15D;
#N canvas 0 0 1280 700 icsm15E 0;
#X obj 1100 650 icsm_anterior icsm15E icsm15D;
#X obj 1150 650 icsm_sobe icsm15E icsm1.pd;
#X obj 1200 650 icsm_proximo icsm15E icsm15F;
#X obj 100 70 cnv 15 14 14 empty empty Altura_Musical_e_Intervalos_Musicais
0 0 0 28 -262144 -38 0;
#X text 100 110 O termo ALTURA MUSICAL designa a posição de um som
periódico ou quase periódico no eixo perceptual associado aos termos
GRAVE e AGUDO. Esse eixo possui uma relação com o eixo dos valores
de frequências audíveis \, entre 20 Hz e 20 kHz \, porém as variações
na percepção de altura possuem uma relação não-linear com as variações
nos valores de frequências. Em outras palavras \, "passos" ou "deslocamentos"
iguais em um desses eixos não corresponderão a passos/deslocamentos
iguais no outro., f 107;
#X text 100 210 Grosseiramente falando \, ocorre com a altura musical
um fenômeno parecido com o que observamos em relação à amplitude
\, onde a resposta do ouvido estava relacionada aproximadamente com
o logaritmo do parâmetro físico correspondente. Assim \, RAZÕES
ENTRE FREQUÊNCIAS do tipo R=F1/F0 serão mapeadas através do log
em DIFERENÇAS do tipo log(R) = log(F1)-log(F0) \, de tal modo que
o deslocamento percebido entre as frequências F0 e F1 será semelhante
ao deslocamento entre F1 e F2=R*F1 (pois log(F2/F1)=log(R)) \, ou entre
F2 e F3=R*F2 e assim por diante. Pode-se obter uma ESCALA DE PASSOS
PERCEPTUAIS IGUAIS construindo-se PROGRESSÕES GEOMÉTRICAS da forma
F0 \, R*F0 \, R²*F0 \, R³*F0 \, e assim por diante. RAZÕES INVERSAS
representam simplesmente passos na direção contrária \, pois se
F1=R*F0 então F0=(1/R)*F1., f 107;
#X text 100 370 Algumas razões específicas entre frequências possuem
um espaço de destaque devido a uma série de propriedades físicas
\, matemáticas e perceptuais. A razão R=2 recebeu o nome de OITAVA
por motivos históricos \, pois a partir de uma altura musical associada
a uma frequência inicial F0 se atingia a frequência 2*F0 como o oitavo
passo em uma escala musical chamada de DIATÔNICA. Sons cujas frequências
são relacionadas por oitavas são percebidos como tão similares que
musicalmente recebem os mesmos nomes: por exemplo \, as alturas denotadas
por A1 \, A2 \, A3 e A4 são todas chamadas de LÁ \, e estão convencionalmente
associadas às frequências A1=55 Hz \, A2=110 Hz \, A3=220 Hz e A4=440
Hz. Outras razões simples \, como 3/2 e 5/4 \, já faziam parte da
teoria musical na época de PITÁGORAS \, sendo (hoje) chamadas de
QUINTA JUSTA e TERÇA MAIOR (esses nomes também estão relacionados
com a escala diatônica). Um intervalo musicalmente importante é o
SEMITOM (em um sistema chamado TEMPERAMENTO IGUAL) \, que divide a
oitava em 12 intervalos iguais \, ou seja \, que satisfaz a equação
R¹²=2 \, e portanto R=2^(1/12)~1.05946. A escala musical correspondente
a essa razão é chamada de ESCALA CROMÁTICA., f 107;
#X obj 604 606 icsm_url https://en.wikipedia.org/wiki/Equal_temperament
;
#X obj 104 606 icsm_url https://en.wikipedia.org/wiki/Interval_(music)
;
#X text 637 608 Temperamento igual (Wikipedia);
#X text 136 607 Intervalos musicais (Wikipedia);
#X coords 0 0 1 1 100 100 0;
#X restore 600 0 pd icsm15E;
#N canvas 0 0 1280 700 icsm15F 0;
#X obj 1100 650 icsm_anterior icsm15F icsm15E;
#X obj 1150 650 icsm_sobe icsm15F icsm1.pd;
#X obj 1200 650 icsm_proximo icsm15F icsm15G;
#X obj 100 70 cnv 15 14 14 empty empty Experimento_com_Intervalos_Musicais
0 0 0 28 -262144 -38 0;
#X obj 319 256 hsl 128 20 0.0001 1 1 0 empty \$0F_vol_r Volume -2 -8
0 16 -262144 -1 -1 0 0;
#X floatatom 316 280 8 0 1 0 - - #0F_vol;
#X text 302 255 0;
#X text 450 255 1;
#X obj 193 246 tgl 24 0 \$0F_mute \$0F_mute_r MUTE 28 12 0 18 -262130
-1 -1 0 1;
#X obj 649 256 hsl 256 20 20 20000 1 0 empty \$0F_F0_r Frequência_F0
-2 -8 0 16 -262144 -1 -1 0 0;
#X floatatom 646 280 8 20 20000 1 Hz - #0F_F0;
#X text 909 254 20k;
#X text 622 255 20;
#X msg 975 262 2;
#X msg 975 292 1.5;
#X msg 975 322 1.25;
#X text 1076 322 (terça);
#X text 1076 352 (semitom);
#X text 1076 292 (quinta);
#X text 1076 262 (oitava);
#X floatatom 646 551 8 0 0 1 Hz - #0F_freq;
#X floatatom 508 256 5 0 60 2 Passos_(N) #0F_N_r #0F_N;
#X obj 649 522 hsl 256 20 20 20000 1 0 empty empty Frequência_escutada_(log)
-2 -8 0 16 -262144 -1 -1 0 1;
#X text 909 520 20k;
#X text 622 521 20;
#X text 974 242 Razão (R);
#X text 595 591 <- observe que as PGs em escala log "viram" PAs.,
f 25;
#N canvas 0 0 1009 709 \$0_computa_frequência 0;
#X text 36 34 Esse patch computa a frequência da forma F0*R^N sempre
que um desses parâmetros é alterado na interface correspondente.
O objeto principal é o [expr $f2*pow($f3 \, $f1)] \, e o conceito
novo é a ideia de inlets QUENTES e FRIOS., f 87;
#X obj 129 262 expr $f2*pow($f3 \, $f1);
#X obj 296 148 t b f;
#X obj 475 148 t b f;
#X text 36 334 A necessidade do sequenciamento de ações representado
pelos objetos [trigger bang float] tem origem no fato de que o objeto
[expr] utilizado possui 3 inlets \, sendo que em Pd apenas o inlet
mais à esquerda provoca o cálculo da expressão (no jargão Pd esse
é o inlet "quente" \, sendo os demais "frios" \, ou seja \, recebem
valores mas não produzem saída). A ideia de inlets quentes e frios
é muito útil para sincronizar cálculos que dependem de entradas
que não estão disponíveis simultaneamente \, oferecendo maior controle
temporal sobre o instante exato em que as expressões são calculadas
\, que é o instante em que o inlet quente é acionado. Observe que
a convenção de inlets quentes mais à esquerda explica a convenção
de que as saídas dos objetos são disponibilizadas sempre da direita
para a esquerda., f 87;
#X text 36 544 No exemplo acima \, o objeto [expr] apenas produzirá
o resultado quando receber o valor correspondente ao parâmetro $f1
\, no nosso caso o N (mas podíamos ter escolhido os parâmetros em
qualquer ordem). A cada vez que um valor de F0 for recebido \, esse
valor será repassado pelo [trigger] para a 2a entrada do [expr] \,
e em seguida um bang no inlet quente do [expr] fará a expressão ser
calculada com o último valor recebido no lugar de $f1 (esses parâmetros
funcionam como MEMÓRIAS ou variáveis internas ao objeto). O mesmo
comportamento será observado quando um novo valor de R for recebido.
, f 87;
#X obj 129 291 outlet;
#X obj 129 119 r \$0F_N;
#X obj 296 119 r \$0F_F0;
#X obj 475 119 r \$0F_R;
#X connect 1 0 6 0;
#X connect 2 0 1 0;
#X connect 2 1 1 1;
#X connect 3 0 1 0;
#X connect 3 1 1 2;
#X connect 7 0 1 0;
#X connect 8 0 2 0;
#X connect 9 0 3 0;
#X restore 646 388 pd \$0_computa_frequência;
#X text 644 361 Calcula a expressão F0*R^N:;
#X obj 975 404 nbx 8 20 1 4 0 1 \$0F_R \$0F_R_r Tamanho_do_Passo 0
-8 0 16 -262144 -1 -1 1 256;
#N canvas 0 0 664 638 \$0F_escala 0;
#X obj 98 214 t b f;
#X obj 68 155 r \$0F_F0;
#X obj 98 185 r \$0F_R;
#X text 63 38 Representa graficamente os valores de frequência F0*R^N
associados aos passos da "escala" N=0 \, 1 \, 2 \, ..., f 47;
#X obj 68 245 pack f f;
#X obj 68 289 ofelia f \; x = ofArray("\$0F_frequências") \; --[[
calcula maior passo "audível" ]] \; if a[2]==1 then N=20 \; else N
= math.min(20 \, math.floor(1+math.log(20000/a[1])/math.log(a[2])))
\; end \; --[[ computa as frequências dos passos audíveis ]] \; for
n = 0 \, N-1 do \; x[n] = math.log(a[1]*a[2]^n) \; end \; --[[ preenche
o resto da tabela com o valor máximo ]] \; for n = N \, 19 do \; x[n]
= math.log(20000) \; end \;;
#X text 153 245 <- junta as mensagens em uma lista;
#X connect 0 0 4 0;
#X connect 0 1 4 1;
#X connect 1 0 4 0;
#X connect 2 0 0 0;
#X connect 4 0 5 0;
#X restore 308 332 pd \$0F_escala;
#N canvas 0 0 290 333 \$0F_síntese 0;
#X obj 72 191 expr 1-$f1;
#X obj 65 224 *~ 1;
#X obj 65 124 *~ 0;
#X obj 66 31 r \$0F_freq;
#X obj 92 96 r \$0F_vol;
#X obj 66 63 osc~ 400;
#X obj 65 263 dac~;
#X obj 72 162 r \$0F_mute;
#X connect 0 0 1 1;
#X connect 1 0 6 0;
#X connect 1 0 6 1;
#X connect 2 0 1 0;
#X connect 3 0 5 0;
#X connect 4 0 2 1;
#X connect 5 0 2 0;
#X connect 7 0 0 0;
#X restore 105 332 pd \$0F_síntese;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0F_frequências 20 float 2;
#X coords 0 10 20 3 400 200 1 0 1;
#X restore 185 413 graph;
#X text 111 633 Passos:;
#X text 188 633 0;
#X text 208 633 1;
#X text 228 633 2;
#X text 248 633 3;
#X text 268 633 4;
#X text 288 633 5;
#X text 308 633 6;
#X text 328 633 7;
#X text 348 633 8;
#X text 368 633 9;
#X text 384 633 10;
#X text 405 633 ...;
#X obj 646 417 min 20000;
#X text 746 419 limita às freqs audíveis, f 14;
#X text 100 110 Esse experimento visa ilustrar a ideia de INTERVALOS
MUSICAIS \, que correspondem a razões entre frequências. Outra maneira
de compreender que nosso ouvido "percebe" o log da frequência é observar
que razões iguais entre frequências são percebidas como passos iguais
no "espaço perceptual" das alturas musicais. Escolha uma frequência
F0 de base e uma razão R (passo multiplicativo) \, e observe como
seu ouvido percebe as progressões geométricas de frequências da
forma F0*R^N para N=0 \, 1 \, 2 \, ... \, que formam ESCALAS (ou seja
\, escadas) no gráfico abaixo., f 107;
#X text 141 443 5k;
#X text 131 422 10k;
#X text 131 401 20k;
#X text 121 470 2000;
#X text 121 490 1000;
#X text 131 510 500;
#X text 131 536 200;
#X text 131 556 100;
#X text 141 575 50;
#X text 141 601 20;
#X obj 185 613 hradio 20 1 0 20 \$0F_N \$0F_N_r empty 0 -8 0 10 -262144
-1 -1 0;
#X obj 165 415 vsl 20 198 20 20000 1 0 empty \$0F_freq empty 0 -9 0
10 -262144 -1 -1 0 1;
#X msg 975 352 1.05946;
#N canvas 0 0 753 516 mágica 0;
#X obj 44 250 spigot;
#X obj 164 235 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X msg 111 310 0;
#X obj 164 177 loadbang;
#X msg 164 206 1;
#X obj 44 281 t f b;
#X obj 44 310 pipe 1;
#X obj 44 368 pipe 1;
#X obj 44 339 t b f;
#X obj 44 133 r \$0F_N;
#X obj 44 433 s \$0F_N_r;
#X obj 369 176 f \$0;
#X obj 369 88 r pd;
#X obj 369 117 route dsp;
#X obj 369 146 sel 0;
#X text 41 30 Esse subpatch conecta alguns sliders do patch sem criar
loops infinitos, f 27;
#X text 366 30 e reseta alguns controles quando o DSP é desligado
, f 25;
#X msg 369 220 \; \$1F_vol_r 0 \; \$1F_N_r 0 \; \$1F_F0_r 0 \; \$1F_R_r
1 \; \$1F_frequências const 3;
#X connect 0 0 5 0;
#X connect 1 0 0 1;
#X connect 2 0 1 0;
#X connect 3 0 4 0;
#X connect 4 0 1 0;
#X connect 5 0 6 0;
#X connect 5 1 2 0;
#X connect 6 0 8 0;
#X connect 7 0 4 0;
#X connect 8 0 7 0;
#X connect 8 1 10 0;
#X connect 9 0 0 0;
#X connect 11 0 17 0;
#X connect 12 0 13 0;
#X connect 13 0 14 0;
#X connect 14 0 11 0;
#X coords 0 -1 1 1 2 2 2 0 0;
#X restore 583 613 pd mágica;
#X obj 100 243 icsm_dsp;
#X connect 4 0 5 0;
#X connect 9 0 10 0;
#X connect 13 0 29 0;
#X connect 14 0 29 0;
#X connect 15 0 29 0;
#X connect 22 0 20 0;
#X connect 27 0 46 0;
#X connect 46 0 22 0;
#X connect 61 0 29 0;
#X coords 0 0 1 1 100 100 0;
#X restore 750 0 pd icsm15F;
#N canvas 0 0 1280 700 icsm15G 0;
#X obj 1100 650 icsm_anterior icsm15G icsm15F;
#X obj 1150 650 icsm_sobe icsm15G icsm1.pd;
#X obj 1200 650 icsm_proximo icsm15G icsm15H;
#X obj 100 70 cnv 15 14 14 empty empty Um_pouco_mais_sobre_percepção_de_altura
0 0 0 28 -262144 -38 0;
#X text 100 260 ou equivalentemente freq(M) = 440*2^((M-69)/12).;
#X text 190 235 MIDI(f) = 12*log_2(f/440)+69;
#X text 100 110 Na teoria do mapeamento logarítmico entre frequências
em Hertz e altura musical percebida \, podemos expressar por exemplo
as alturas no sistema MIDI usando valores inteiros (em semitons) entre
0 e 127 \, onde os valores de 0 a 11 representam as notas da escala
cromática (entre Do e Si ou entre C e B) na oitava identificada como
-1 na NOTAÇÃO CIENTÍFICA DE PITCH \, e esses valores se repetem
ciclicamente a cada oitava (12-23 na oitava 0 \, que é a primeira
oitava humanamente audível \, 24-35 na oitava 1 \, e assim por diante).
Por convenção \, a nota Lá4 ou A4 ou MIDI=69 corresponde à frequência
de 440 Hz \, dando origem às fórmulas, f 107;
#X obj 722 550 image icsm15_bark.ppm;
#X text 100 300 Entretanto \, a percepção sonora humana é cheia
de nuances. Embora a relação acima modele razoavelmente bem a região
central do âmbito de alturas perceptíveis pela escuta humana \, nos
extremos grave e agudo são observados desvios significativos quando
se comparam tons que ocorrem SEQUENCIALMENTE \, como no caso de MELODIAS
(vale observar que nesses casos a comparação ocorre entre um tom
presente e a MEMÓRIA de um tom passado \, o que é diferente de comparar
dois tons apresentados simultaneamente). Levando em conta essas comparações
\, foi criada a escala de frequências MEL \, com o objetivo de garantir
que diferenças iguais em valores MEL entre tons consecutivos sejam
percebidos como intervalos musicais iguais., f 107;
#X text 890 541 Imagem: Wikimedia Commons;
#X obj 906 496 icsm_url https://en.wikipedia.org/wiki/Bark_scale;
#X obj 1144 540 icsm_url https://commons.wikimedia.org/wiki/File:Bark_scale.png
;
#X text 100 451 Outra escala perceptual relevante no que se refere
à altura musical é a escala BARK \, que considera as diversas BANDAS
CRÍTICAS da audição \, que são faixas de frequência nas quais
a presença de um segundo tom interferiria com a percepção de um
primeiro tom \, devido a um efeito de MASCARAMENTO., f 44;
#X obj 906 457 icsm_url https://en.wikipedia.org/wiki/Mel_scale;
#X text 940 458 Escala MEL (Wikipedia), f 23;
#X obj 746 245 icsm_url https://en.wikipedia.org/wiki/Scientific_pitch_notation
;
#X text 940 497 Escala BARK (Wikipedia);
#X text 780 247 Notação científica de pitch (Wikipedia);
#X coords 0 0 1 1 100 100 0;
#X restore 900 0 pd icsm15G;
#N canvas 0 0 1280 700 icsm15H 0;
#X obj 1100 650 icsm_anterior icsm15H icsm15G;
#X obj 1150 650 icsm_sobe icsm15H icsm1.pd;
#X obj 1200 650 icsm_proximo icsm15H icsm15I;
#X obj 100 70 cnv 15 14 14 empty empty Frequência_e_Amplitude_revisitadas
0 0 0 28 -262144 -38 0;
#X text 100 300 Outra escala psicoacústica relevante para a percepção
de volume é a escala de SONES \, que é definida para tons puros em
1000 Hz como 1 Sone = 40 Phons e cada aumento de 10 Phons corresponde
aproximadamente a dobrar o valor em Sones (portanto 2 Sones = 50 Phons
\, 4 Sones = 60 Phons \, etc)., f 83;
#X obj 1083 423 image icsm15_phons.ppm;
#X obj 776 470 image icsm15_cochlea.ppm;
#N canvas 0 0 1280 700 icsm15H+ 0;
#X obj 139 803 bng 30 250 50 0 empty empty empty 17 7 0 10 -262130
-1 -1;
#X msg 189 801 \; pd-icsm15H+ vis 1;
#X text 6 801 +detalhes(*):;
#N canvas 0 0 920 419 \$0_fletcher_munson 0;
#X obj 56 186 bng 24 250 50 0 \$0_15H+_aceita_vol empty Aceita_volume
28 12 0 16 -262130 -1 -1;
#X obj 56 324 bng 24 250 50 0 \$0_15H+_init empty Reinicializa_experimento
28 12 0 16 -262130 -1 -1;
#N canvas 0 0 1026 706 mágica 0;
#X msg 222 544 init;
#X obj 47 256 osc~ 1000;
#X obj 102 516 dac~;
#X obj 326 387 *~ 0.01;
#X obj 326 352 osc~;
#X obj 405 499 pack f f f;
#X obj 405 529 route 0;
#X obj 326 166 random 1000;
#X obj 326 201 + 12;
#X obj 326 236 expr 20*pow(1000 \, $f1/1024);
#X obj 459 277 r \$0_15H+_vol;
#X obj 222 485 r \$0_15H+_init;
#X obj 326 83 r \$0_15H+_freq;
#X obj 405 428 r \$0_15H+_aceita_vol;
#X text 47 182 Oscilador fixo em 1000 Hz com volume 0.01, f 14;
#X text 491 83 sorteia frequência nova;
#X text 452 166 índices entre 12 e 1011 (exclui extremos da tabela
\, que tem 1024 pontos), f 33;
#X text 606 277 recebe valor de volume;
#X text 519 498 cria mensagem da forma |freq vol<;
#X obj 74 286 r \$0_15H+_dsp;
#X obj 94 410 s \$05_dsp;
#X obj 47 473 *~;
#X obj 74 438 * 0.01;
#X obj 114 380 s \$0_15H+_init;
#X obj 326 312 t f f;
#X obj 405 558 t l b;
#X obj 222 514 t b b;
#X obj 107 620 f \$0;
#X obj 326 112 t b b;
#X obj 388 112 f \$0;
#X msg 444 112 \; \$1_15H+_vol_r 0 \;;
#X msg 107 655 \; \$1_15H+_freq bang \;;
#X text 479 463 não aceita vol=0 (-infty dB);
#X obj 405 462 spigot;
#X obj 459 337 t f f f;
#X text 45 22 A discussão dessa implementação não faz parte do
conteúdo \, entre por sua conta e risco...;
#X obj 365 612 ofelia d \; \; --[[ guarda pares (freq \, amp) selecionados
]] \; local data=ofTable() \; --[[ vetor Pd com a curva de equal-loudness
]] \; local A=ofArray("\$0_A") \; \; --[[ conversões entre frequências
e índices verticais no gráfico (log) ]] \; local function f2i(f)
return math.floor(1024*math.log(f/20)/math.log(1000)) end \; \; local
function i2f(i) return 20*1000^(i/1024) end \; \; --[[ inicializa a
curva com a frequência de 1000 Hz e os extremos 20 Hz e 20000 Hz ]]
\; function ofelia.init() \; data=ofTable() \; --[[ os valores de amplitude
armazenados são na realidade os índices verticais (escala log) ]]
\; data[1] = ofTable(20 \, 0) \; data[2] = ofTable(1000 \, 20*math.log(0.01)/math.log(10))
\; data[3] = ofTable(20000 \, 0) \; ofelia.bang() \; end \; \; --[[
processa um par (frequência \, amplitude) ]] \; function ofelia.list(a)
\; --[[ insere na lista de dados ]] \; local N=#data+1 \; a[2] = 20*math.log(a[2])/math.log(10)
\; local i=1 \; while data[i][1]<a[1] do i = i+1 end \; for j=N \,
i+1 \, -1 do data[j]=data[j-1] end \; data[i]=a \; ofelia.bang() \;
end \; \; --[[ recalcula visualização interpolada da curva ]] \;
function ofelia.bang() \; for i=1 \, #data-1 do \; local i1=f2i(data[i][1])
\; local i2=f2i(data[i+1][1]) \; if i2>i1 then for j=i1 \, i2-1 do
\; A[j]=data[i][2]+(data[i+1][2]-data[i][2])*(j-i1)/(i2-i1) \; end
end \; end \; end \;;
#X obj 74 315 t f f b f;
#X msg 158 349 \; pd dsp \$1;
#X connect 0 0 36 0;
#X connect 1 0 21 0;
#X connect 3 0 2 1;
#X connect 3 0 2 0;
#X connect 4 0 3 0;
#X connect 5 0 6 0;
#X connect 6 0 25 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 9 0 24 0;
#X connect 10 0 34 0;
#X connect 11 0 26 0;
#X connect 12 0 28 0;
#X connect 13 0 33 0;
#X connect 19 0 37 0;
#X connect 21 0 2 1;
#X connect 21 0 2 0;
#X connect 22 0 21 1;
#X connect 24 0 4 0;
#X connect 24 1 5 1;
#X connect 25 0 36 0;
#X connect 25 1 27 0;
#X connect 26 0 0 0;
#X connect 26 1 27 0;
#X connect 27 0 31 0;
#X connect 28 0 7 0;
#X connect 28 1 29 0;
#X connect 29 0 30 0;
#X connect 33 0 5 0;
#X connect 34 0 3 1;
#X connect 34 1 5 2;
#X connect 34 2 33 1;
#X connect 37 0 22 0;
#X connect 37 1 20 0;
#X connect 37 2 23 0;
#X connect 37 3 38 0;
#X restore 617 761 pd mágica;
#N canvas 0 0 450 250 (subpatch) 0;
#X array \$0_A 1024 float 2;
#X coords 0 0 1024 -50 400 280 1 0 0;
#X restore 423 52 graph;
#X text 410 334 20Hz;
#X text 800 334 20kHz;
#X text 619 334 1000Hz;
#X text 389 316 -50;
#X text 389 256 -40;
#X text 389 203 -30;
#X text 389 150 -20;
#X text 389 97 -10;
#X text 369 44 dB: 0;
#X obj 56 44 tgl 24 0 \$0_15H+_dsp empty LIGA/DESLIGA_EXPERIMENTO 28
12 0 18 -262130 -1 -1 0 1;
#X obj 56 254 bng 24 250 50 0 \$0_15H+_freq empty Nova_frequência
28 12 0 16 -262130 -1 -1;
#X obj 59 118 hsl 200 20 0.0001 1 1 0 \$0_15H+_vol \$0_15H+_vol_r Volume
0 -12 0 16 -262144 -1 -1 0 0;
#X coords 0 -1 1 1 900 400 2 0 0;
#X restore 179 255 pd \$0_fletcher_munson;
#X obj 100 70 cnv 15 14 14 empty empty Experimento_de_Fletcher-Munson_simplificado
0 0 0 28 -262144 -38 0;
#X text 100 100 Nesse patch você poderá construir uma curva personalizada
de volume perceptual constante com uma versão simplificada do experimento
de Fletcher-Munson. Você escutará sempre dois tons senoidais \, sendo
um deles de 1000 Hz e outro de uma frequência aleatória. Encontre
um volume que "equilibre" perceptualmente os dois tons \, fazendo com
que você não perceba nenhum deles como mais forte do que o outro
\, e marque a opção "Aceita_volume" para classificar o próximo tom
senoidal. A qualquer momento você pode apertar "Nova frequência"
para pular algum tom que esteja difícil de equilibrar. Se o gráfico
com os ajustes perceptuais ficar muito bagunçado ou errado \, clique
em "Reinicializar experimento" e comece de novo., f 107;
#X connect 0 0 1 0;
#X coords 0 -1 1 1 180 36 2 0 800;
#X restore 807 600 pd icsm15H+;
#X text 100 110 No experimento de percepção de frequência é possível
observar que o volume percebido de um sinal senoidal de amplitude constante
não é idêntico em todas as frequências. Essa dependência da percepção
de volume em função da frequência em sinais senoidais foi estudada
sistemativamente por FLETCHER e MUNSON na década de 1930 \, e está
relacionada com uma escala psicoacústica com unidade PHON. Por definição
\, uma senoide com frequência 1000 Hz possui volume em Phons idêntico
à energia em dB SPL - por exemplo \, uma senoide de 1000 Hz com 40
Phon possui energia de 40 dB SPL. Uma CURVA DE VOLUME CONSTANTE (Equal
Loudness Curve) em X Phons é construída ajustando a energia de senoides
de frequências diferentes de tal modo que aparentem possuir o mesmo
volume perceptual que a senoide original de 1000 Hz com X dB SPL. O
modelo de Fletcher e Munson foi revisado por Robinson e Dadson na década
de 1950 \, dando origem às curvas ISO 226:2003 ilustradas abaixo.
, f 107;
#X text 612 563 Imagem: Wikimedia Commons;
#X text 918 563 Imagem: Wikimedia Commons;
#X obj 866 562 icsm_url https://commons.wikimedia.org/wiki/File:Uncoiled_cochlea_with_basilar_membrane.png
;
#X obj 1172 562 icsm_url https://commons.wikimedia.org/wiki/File:Equal_loudness_no_caption.svg
;
#X text 100 377 Para se medir o volume em Sones de misturas de fontes
sonoras diferentes \, o cálculo é mais complicado. Se dois tons senoidais
são muito próximos \, caindo em uma mesma BANDA CRÍTICA (faixa de
frequências próximas sujeitas a interferências perceptuais) \, suas
energias se somam. Se estiverem em bandas críticas diferentes \, são
os volumes em Sones que se somam. E se as distâncias entre as bandas
críticas ou entre os níveis de volume forem muito grandes \, pode
ocorrer o efeito de MASCARAMENTO \, onde o volume percebido é simplesmente
o máximo dentre os volumes individuais., f 51;
#X obj 103 634 icsm_url https://en.wikipedia.org/wiki/Equal-loudness_contour
;
#X text 136 635 Curvas de volume constante (Wikipedia);
#X obj 542 634 icsm_url https://en.wikipedia.org/wiki/Critical_band
;
#X text 576 635 Banda crítica (Wikipedia);
#X coords 0 0 1 1 100 100 0;
#X restore 1050 0 pd icsm15H;
#N canvas 0 0 1280 700 icsm15I 0;
#X obj 1100 650 icsm_anterior icsm15I icsm15H;
#X obj 1150 650 icsm_sobe icsm15I icsm1.pd;
#X obj 1200 650 icsm_proximo icsm15I icsm16.pd;
#X obj 100 70 cnv 15 14 14 empty empty Experimento_com_Compensação_de_Amplitude
0 0 0 28 -262144 -38 0;
#N canvas 0 0 450 250 (subpatch) 0;
#X array RAf_\$0 1024 float 2;
#X coords 0 1 1024 0 400 280 1 0 0;
#X restore 630 302 graph;
#X obj 127 370 hsl 256 20 20 20000 1 0 empty \$0I_freq_r Frequência
-2 -8 0 16 -262144 -1 -1 0 1;
#X floatatom 124 401 8 20 20000 1 Hz - #0I_freq;
#X text 387 368 20k;
#X text 100 369 20;
#X obj 235 256 tgl 24 0 \$0I_mute \$0I_mute_r MUTE 28 12 0 18 -262130
-1 -1 0 1;
#X obj 630 236 tgl 24 0 \$0I_A \$0I_A_r Liga/Desliga_compensação_(A-weighting)
28 12 0 18 -262130 -1 -1 0 1;
#N canvas 0 0 286 346 \$0I_síntese 0;
#X obj 82 211 expr 1-$f1;
#X obj 75 244 *~ 1;
#X obj 75 144 *~ 0;
#X obj 75 283 dac~;
#X obj 102 116 r \$0I_vol;
#X obj 76 51 r \$0I_freq;
#X obj 76 83 osc~;
#X obj 82 182 r \$0I_mute;
#X connect 0 0 1 1;
#X connect 1 0 3 0;
#X connect 1 0 3 1;
#X connect 2 0 1 0;
#X connect 4 0 2 1;
#X connect 5 0 6 0;
#X connect 6 0 2 0;
#X connect 7 0 0 0;
#X restore 103 465 pd \$0I_síntese;
#X obj 633 582 hsl 395 20 20 20000 1 0 empty \$0I_freq Frequência_(log)
240 35 0 16 -262144 -1 -1 0 1;
#X obj 610 304 vsl 20 274 0 1 0 0 empty \$0I_RAf empty 0 -9 0 16 -262144
-1 -1 0 1;
#X obj 1030 304 vsl 20 274 0 0.1 0 0 empty \$0I_vol Vol 0 -12 0 16
-262144 -1 -1 0 1;
#N canvas 0 0 705 460 \$0I_amplitude 0;
#X obj 51 401 s \$0I_vol;
#X obj 51 119 expr int(1024*log10($f1/20)/3);
#X obj 51 367 mux;
#X obj 170 269 r \$0I_A;
#X obj 298 255 s \$0I_RAf;
#X obj 51 185 expr 0.01 \; min(1 \, 0.01/RAf_\$0[$f1]) \; RAf_\$0[$f1]
;
#X text 365 119 converte frequência em índice do gráfico R_A(f)
, f 24;
#X text 319 183 0.01 é a amplitude não compensada;
#X text 319 204 a compensação é feita por divisão;
#X text 319 225 valor enviado para o gráfico;
#X obj 51 13 r \$0I_freq;
#X obj 51 82 f;
#X obj 170 298 t b f;
#X obj 170 331 s \$0I_recalc;
#X obj 68 51 r \$0I_recalc;
#X obj 103 367 declare -lib zexy;
#X connect 1 0 5 0;
#X connect 2 0 0 0;
#X connect 3 0 12 0;
#X connect 5 0 2 0;
#X connect 5 1 2 1;
#X connect 5 2 4 0;
#X connect 10 0 11 0;
#X connect 11 0 1 0;
#X connect 12 0 13 0;
#X connect 12 1 2 2;
#X connect 14 0 11 0;
#X restore 103 504 pd \$0I_amplitude;
#X text 1053 437 <- aqui aparece o volume compensado (aplicado no sinal)
, f 11;
#X text 100 100 Nesse experimento você poderá testar o efeito da
compensação de amplitude conhecida como A-weighting \, definida na
norma IEC 61672:2003 e ilustrada pela função R_A(f) abaixo. Esses
valores corresponderiam simplificadamente à amplitude relativa percebida
pelo ouvido em função da frequência \, e a compensação é feita
pela divisão da amplitude do oscilador pela função R_A(f). Essa
curva tem por referência o valor de 40 phons \, que é um volume relativamente
baixo \, então a aderência do modelo depende também de um ajuste
baixo do volume do fone-de-ouvido ou alto-falante., f 107;
#X text 516 437 este -> é o valor da função R_A(f), f 9;
#N canvas 0 0 945 561 mágica 0;
#X obj 284 75 t f f;
#X obj 284 104 expr 20*pow(10 \, 3*$f1/1024);
#X obj 41 103 ofelia f \; local x=ofOutlet(this) \; for i=0 \, 1023
do \; x:outletFloat(0 \, i) \; end;
#X obj 284 134 expr pow(12194 \, 2)*pow($f1 \, 4)/((pow($f1 \, 2)+pow(20.6
\, 2))*sqrt((pow($f1 \, 2)+pow(107.7 \, 2))*(pow($f1 \, 2)+pow(737.9
\, 2)))*(pow($f1 \, 2)+pow(12194 \, 2))) \; int(1024*log10($f1/20)/3)
;
#X obj 284 223 tabwrite RAf_\$0;
#X obj 41 73 loadbang;
#X text 349 75 Preenche a tabela com os valores da fórmula;
#X text 36 44 Fórmula: R_A(f) = 12194^2f^4/((f^2+20.6^2)sqrt((f^2+107.7^2)(f^2+737.9^2))(f^2+12194^2)
, f 88;
#X obj 41 392 f \$0;
#X obj 41 291 r pd;
#X obj 41 323 route dsp;
#X obj 41 352 sel 0;
#X text 166 293 reinicializa seletor de frequência ao desligar o DSP
;
#X msg 41 426 \; \$1I_freq_r 0 \; \$1I_A_r 0;
#X connect 0 0 1 0;
#X connect 0 1 4 1;
#X connect 1 0 3 0;
#X connect 2 0 0 0;
#X connect 3 0 4 0;
#X connect 5 0 2 0;
#X connect 8 0 13 0;
#X connect 9 0 10 0;
#X connect 10 0 11 0;
#X connect 11 0 8 0;
#X coords 0 -1 1 1 2 2 2 0 0;
#X restore 1028 582 pd mágica;
#X obj 142 253 icsm_dsp;
#X obj 103 594 icsm_url https://en.wikipedia.org/wiki/A-weighting;
#X text 136 595 A-weighting (Wikipedia);
#X connect 5 0 6 0;
#X coords 0 0 1 1 100 100 0;
#X restore 0 50 pd icsm15I;
#X connect 0 0 1 0;
#X coords 0 -1 1 1 2 2 2 0 0;
#X restore 0 0 pd icsm15_;
#X obj 1100 650 icsm_anterior icsm15.pd icsm14C;
#X obj 1150 650 icsm_sobe icsm15.pd icsm1.pd;
#X obj 1200 650 icsm_proximo icsm15.pd icsm15A;
#X obj 0 0 icsm_cabecalho;
#X obj 100 200 cnv 15 14 14 empty empty 1.5_Amplitude_e_Frequência
0 0 0 34 -262144 -38 0;
#X text 100 330 A AMPLITUDE do sinal se refere à variação vertical
das amplitudes instantâneas \, ou seja \, dos valores das amostras
individuais \, e permite caracterizar sinais de acordo com sua "força"
ou "volume" sonoro., f 107;
#X text 100 270 Estes dois são possivelmente os parâmetros mais importantes
para caracterizar sinais sonoros:, f 107;
#X text 100 410 A FREQUÊNCIA se refere à "taxa de repetição" ou
periodicidade do sinal \, e permite caracterizar sinais no âmbito
da ALTURA MUSICAL \, que por sua vez é um parâmetro perceptual associado
aos termos GRAVE e AGUDO., f 107;
#X coords 0 0 1 1 100 100 0;
